,Title,Link,Content
0,What is a Knowledge Base,"https://wiki.genexus.com//commwiki/wiki?1836,Knowledge+Base","To create a new software system with GeneXus you must create a Knowledge Base (KB).
A Knowledge Base stores the Users' Views about the business reality to be modeled. Those User's Views are described in the Knowledge Base using Objects of many kinds.
The stored knowledge is structured information that is so pure and platform-independent, that GeneXus can make inferences to obtain more knowledge and also automatically generate the system (database and the application programs) in as many platforms you decide.
That is the reason behind a Knowledge Base is not just called ‘Project’ as used in common Software development jargon.
"
1,Knowledge Base Creation,"https://wiki.genexus.com//commwiki/wiki?9596,New+Knowledge+Base","You can create a new Knowledge Base by selecting File > New > Knowledge Base in the GeneXus menu bar or by pressing Ctrl+Shift+N.
The GeneXus Start Page also gives the option to create a new Knowledge Base.
When you create a new Knowledge Base, a dialog box will be displayed to complete some details, as shown in the image below:

Here you have to complete the required data:
Name: The name of the KB that will be created.
Location: The path where the KB will be created.
Prototyping Target: Indicates if you want the programs to be generated by GeneXus in your local prototyping machine or in the GeneXus Prototyping Cloud.
User Interface Language: The language in which you want the application to be generated; that is, the language in which GeneXus will generate button labels, messages, etc.
Back end box

Prototyping Environment: One of the possible programming languages. The language selected will be the one used by GeneXus to generate the back-end programs corresponding to the application, as well as the programs for creating and maintaining the database.
Data Source: Defines the DBMS over which the database will be created, accessed, and maintained.


Front end box: Indicates the programming languages you want GeneXus to generate the front-end applications programs. .NET is the language offered by default to generate front-end applications for the Web. You can select others to generate Web and/or Native Mobile applications, too. 
Advanced tab: Sets details about the database that will store the information related to the Knowledge Base. This is not the database corresponding to your application but another one that will store the information relative to definitions you will include in your Knowledge Base.
Once the information required has been completed, you only have to press the Create button.
When the new Knowledge Base is created, a Design System Object will be automatically created with the name of the KB, that is, <KB Name>, which is configured as the Default Style at the KB version level.
In addition, the GeneXusUnanimo module is installed since the created Design System object will contain the import of Unanimo.
Considerations
Use alphanumeric characters (a-zA-Z0-9) to name a KB, taking into account that the name cannot begin with numbers. The character ""-"" is not supported; use ""_"" instead.
See Also
Team Development with GeneXus Server
New Knowledge Base - Advanced tab
Videos
Creation of the Knowledge Base
"
2,GeneXus IDE,"https://wiki.genexus.com//commwiki/wiki?5272,Category%3AGeneXus+IDE","GeneXus provides an intuitive and consistent User Interface, IDE.
It is divided into windows, toolbars, and the main menu:

Main window (Start Page)
KB Explorer
Toolbar (offers an easy-to-use interface for commonly used functions in GeneXus) 
Properties window 
Output (displays the output of the actions performed)
The on-screen position of these windows and toolbars is completely customizable.
 
For example, you can change the position of a toolbar or hide a window and show it again using this menu option.
Also, you can control docking behavior by clicking on the pin button. In this way, you could also fix them in one position or arrange them differently on the screen.
After creating a Knowledge Base, the IDE content changes. For example, in the KB Explorer window, a tree structure will be created. Its root will be the name of the Knowledge Base given by you, and below it will appear the GeneXus objects that you are going to define.
If no Knowledge Base is open, the main window will show the start page. The start page displays dynamic information about GeneXus and the GeneXus community (news as well as solutions posted by other developers). It shows recently opened projects with the option to reopen them and also provides an option to create a new project.



"
3,Transaction object,"https://wiki.genexus.com//commwiki/wiki?1908,Category%3ATransaction+object","Describes an object or actor of reality, defining the structure of the database, business rules, and the UI for data manipulation.
Description
Transactions are the first GeneXus objects you create in a Knowledge Base, as they allow you to describe objects or actors of reality. We recommend paying attention to the nouns used by the users when describing their reality and needs, to identify which Transactions you must create (I.e., Customer, Country, etc.).
Each Transaction contains the following selectors:

Structure
The Transaction structure allows you to define the attributes or fields that describe the object of reality.
			The structure may have one Level or several Levels (nested or parallel). The attributes that belong to the same level will be entered, updated, and deleted together. It is necessary to define, among the attributes making up each level, an attribute or set of attributes, acting as a unique identifier (primary key).


Web Layout
GeneXus automatically creates a Web Layout according to the defined structure. This layout will allow users to add, change and delete data at runtime.


Rules
This section is used to define specific behavior rules for the Transaction. For example, validations for the entered data, etc.


Events
This section allows you to define events with idle code, which are activated in response to certain actions by the user or the system.


Variables
This section allows you to define variables that will be local to the Transaction (temporary, in memory).


Help
Here you can write help texts, which users will be able to refer to during Transaction runtime.


Documentation
Here you can write technical text, in wiki format, to be used as documentation of the system.


Patterns
Here you can apply Patterns to the Transaction. Patterns allow us to empower our applications by easily adding new features! When you apply a pattern, GeneXus creates all the necessary objects to provide the desired behavior without the need for us to program them.

 Work With for Web. You can apply the Work With Patterns to the Transaction. The Work With Pattern is one of the best-known and most useful patterns in business applications.

 Work With for Smart Devices. You can apply the Work With for Smart Devices object to the Transaction. In user interfaces, we frequently find a view that shows a list of items and when one of them is selected, that item's detail is displayed. Sometimes this pattern is called Master-DetailTransaction.
GeneXus analyzes the Transaction structures and generates the necessary programs to create the database (if it doesn't exist), which will be automatically normalized to third normal form, according to the main theories of relational databases. In other words, GeneXus extracts the knowledge from the Transaction structures to define the physical tables to be created or updated in the database. After that, GeneXus also generates programs (forms with several functionalities) to interact with the database previously created.
See Also
GeneXus objects
Transaction Object Limits
GeneXus Knowledge Base Limits
Triggering context for Events and Rules
Videos
First Transaction design
 Defining more Transactions
 Working with attributes and domains
"
4,Structure,"https://wiki.genexus.com//commwiki/wiki?7661,Transaction+Structure","The Transaction object Structure allows you to define the attributes or fields that describe that object of reality and how they relate to each other.  

To save the changes made, you must either press CTRL + S or click on the Save icon located in the Main Toolbar.
See Also
Transaction’s Structure Editor
Object Editors

"
5,Attributes definition,"https://wiki.genexus.com//commwiki/wiki?7240,Attribute+definition","In every Transaction structure, you have to define the attributes or fields that describe that object of reality.
Suppose you were asked to record, for each customer, his/her name, last name, address, phone, and email. Therefore, the data that must be recorded for each customer matches the attributes that have to be created for the Customer Transaction.
Note that the first line is created for you to enter the first attribute:

If you press the “dot” key on the keyboard, GeneXus automatically shows the Transaction name as a prefix in the attribute name:

You only have to type ""Id"" after the ""Customer"" prefix to complete the first attribute name. Next, you press the Tab key and choose the data type that will be stored for this attribute:

The data type combo box displays the data types available in GeneXus. For this attribute you can leave the default data type, that is to say: Numeric of 4 digits (with no decimals).
Pressing Enter opens a new line for you to start creating the second attribute.
Note that an icon key is associated with the first line. The reason is that in every Transaction, an attribute – or set of attributes – must be set with an identifier or key role.
Videos
First Transaction design
See also
Insert Attribute/Variable Dialog

"
6,Data Types,"https://wiki.genexus.com//commwiki/wiki?6558,Category%3AData+Types","The GeneXus Data Types can be divided into:
Basics: the very well-known data types (Numeric, Character, etc.).
Business Components: to use the Business Logic of Transactions in other objects, use Business Components.
Extended Types: those used to handle things like Files, XMLs, Directories, Web sessions, Mail sessions, Excel and Word documents, etc.
Structured Data Types: it is the GeneXus object which allows defining complex data structures.
Where are Data Types used?
In an Attribute definition: only Basics are allowed
In a Domain definition: all except Business Components are allowed
In a Variable definition: all kinds of data types are allowed
In the members of a Structured Data Type definition: all kinds of data types are allowed
"
7,GeneXus Domains,"https://wiki.genexus.com//commwiki/wiki?7221,Category%3AGeneXus+Domains","Domains aim at creating global data type definitions.
It is common to have attributes sharing the same definition, though no direct relationship can be established between them. For example, different prices or amounts attributes may share the same data type (i.e.: ProductPrice, ServicePrice, InvoiceAmount, etc.). So, you can define a domain named Price as being a numeric type with a maximum length of 9 and several attributes and variables may be defined based on that domain.
One of the advantages the domains provide is that, if later on, you need prices to be Numeric of a different length, changing the domain definition will be enough to update all the attributes and variables based on that domain in a single step.
Because the use of Domains leads to a higher level of abstract application definition, it is recommended that all attributes be associated with a Domain definition.






"
8,Domain definition,"https://wiki.genexus.com//commwiki/wiki?7239,Domain+definition","By selecting View > Domains in the GeneXus Toolbar, you can view and manage the defined Domains in the Knowledge Base.
GeneXus automatically creates some domains in each Knowledge Base and of course, you can define your own domains.
When you click on a given domain, the Properties Window is refreshed with that domain properties.
Generic properties that every domain has:
Properties


Name


Description


Based on


Data type


Enum values
Then, depending on the data type configured, different properties are offered.
See Also
GeneXus Domains




"
9,Nullable property - Attribute,"https://wiki.genexus.com//commwiki/wiki?7642,Nullable+property+-+Attribute","The null value for a given attribute should be considered as ""not specified"" or ""not available"" or ""not assigned"". It is different from the ""empty"" value that is a special value (i.e. zero for numeric data, empty string for character data, etc.). As from GeneXus 9.0, you can specify, in a Transaction's structure, whether or not an attribute can have a null value. This information is useful for several purposes:
Protect data
Improve referential integrity controls
Enable better join performance
Null Definition
Changes to attribute nullability can be done at the Transaction level by checking or unchecking the Nullable column. It can be set for any attribute that is stored in the underlying table except for the primary key attributes (that do not support the null value by definition).

The Transaction's Nullable column can take the following values:
No: means that the attribute in the underlying Table does not allow the null value.
Yes: means that the attribute in the underlying table allows the null value.
[Compatible]: This is a special compatibility value that is available only in Knowledge Bases that have been converted from GeneXus prior to 9.0. See Compatibility Section in Null Property (GeneXus 9.0) for more details.
The default value is No.
Parallel Transactions
Parallel Transactions are Transactions having the same Primary Key composition in a given level. If there are Parallel Transactions in a Knowledge Base, they share null definitions. This means that the last Parallel Transaction saved from a set, overwrites previous null definitions for all the set.
Why should you care about Nulls?
Nulls are very important in the relational model. Allowing the null value for a given attribute means that it may, under certain circumstances, be ""ignored"" as its value is ""not set"". On the other hand, if an attribute does not allow the null value, a valid value must always be assigned to it. Nulls information is used in GeneXus for defining Data Base tables and referential integrity controls, to determine the Join Type used to navigate de Data Base and check program's logic.

Data Base tables
Nulls definition is used by GeneXus when it creates KB tables. The IAR (Impact Analysis Report) shows Nulls capabilities of every attribute on each KB table. Changing Nulls definition forces a database reorganization.

Referential Integrity
Tables in a KB relate to each other. Cross references between them are made through foreign keys and primary keys. Null definitions for attributes comprising a foreign key let Genexus know how ""strong"" these references are. For example: if none of the attributes comprising a foreign key allow the null value. This is a strong reference (also known as a not null reference): it states that, no matter what happens, the foreign key must always point to an existing Primary Key value of the referenced table. On the other hand, a foreign key having at least one attribute supporting the null value is a weak reference (also known as null reference) and states that if this (or these) attribute(s) are null (any of them if many) the reference should not be checked.

When a foreign key is a compound key (with more than one attribute) and nulls are allowed for any of its attributes, new references may be defined if the remaining attributes comprise a foreign key too, as in the following example.
COUNTRY
CITY
CLIENT


CountryId*
CountryId*
ClientId*


CountryDsc
CityId*
ClientName


 
CityDsc
CountryId


 
 
CityId
In the CLIENT Transaction structure, the CountryId and CityId attributes make up a compound foreign key for the CITY table. If null values are not allowed for either CountryId or CityId, the reference's existence is unconditionally verified. On the other hand, if null values are allowed for CityId, reference to table CITY will be checked only if CityId is not null, and a reference to the table COUNTRY needs to be created. This last reference is needed to avoid entering an invalid (non-existing) CountryId when CityId is null.
Determining Join Type
Join refers to how tables are ""linked"" to retrieve data to fulfill a request (""For each""s, either explicit or implied). As this is written, Genexus supports two types of Joins: Natural and Outer. Natural means that if, for example, two tables are joined, records for not matching join conditions should not be retrieved. Outer means that records not matching join conditions must be retrieved.
Based on Null definitions for foreign keys, Genexus knows when to use Natural (not null reference) or Outer (nullable references).
Checking program logic
Null definitions can be used to check program logic. Basically, to avoid setting the null value for attributes that do not allow it.
Nulls in navigation reports
Navigation reports do not normally show information about null definitions. They do show, however, the effects of null definitions, for example:
A '~' symbol is prefixed to the table icon when nulls are allowed (Outer Join)
The 'allowing nulls' suffix is added to 'READ <TABLE>' in the Detailed Navigation Report.
An '=' symbol is prefixed to the table icon when nulls are not allowed (Natural Join).
Nulls and Foreign Keys Summary
If a foreign key has the Null property set to 'No' for all its attributes:
	
Not null references will be allowed when inserting or updating.
Joins referencing these tables will be generated as Natural Joins.
If a foreign key has some of its Compose attribute set to Yes:
	
Null values will be allowed when inserting or updating.
New referential integrity control is performed if other attributes of this FK match with another Primary Key.
Joins referencing these tables will be generated as Outer Joins.
Specification and Reorganization Controls
Specification controls
If a program (Transaction or Procedure) inserts a record in a table with no referenced attributes with null value property in Yes, and the Initialize Not Referenced Attributes property is set to No, the following error message appears: spc0081: Attributes %1 do not allow nulls in table %2 and are not referenced %3.
To fix the error:
If the program is a Transaction, you may reference these attributes in the transaction structure or disable insertion in the appropriate level. Use the 'error() if insert' rule.
If it is a Procedure, the 'New' group must reference them. Otherwise, you may change the nullability property of these attributes.
Set the Initialize not referenced attributes property to Yes.
If the Nullvalue() function is assigned to an attribute that doesn't support null values, and the Generate Nulls for Nullvalue() property is set to Yes, the following error occurs: spc0082: Attribute %1 in table %2 does not allow nulls.
To fix the error:

Remove the assignment and change the Generate Null for Nullvalue() property value, or
Change the attribute nullability for this table.
If a foreign key doesn't allow nulls and the Allownulls rule is specified for it, the following message appears: spc0085: AllowNulls rule conflict with null definition for foreign key %1.
To fix the error:

Remove the Allownulls rule (it should not be necessary) and change the nullability of foreign key attributes as needed.
Reorganization Controls
When changing an attribute Null=Yes to Null=No, or vice versa, a reorganization takes place. If the modified attribute belongs to a foreign key, this reorganization can change the foreign key constraint definition. If the attribute doesn't belong to a foreign key:
Changing from Null=No to Null=Yes doesn't imply any problems because a new value is added (the null one) and the existent data cannot have it.
Changing from Null=Yes to Null=No deletes a possible value of the existent data. To be able to reorganize the data without any errors in the process, you have to replace the null values with one of two possible values: the one specified in the Initial Value property or, in case this value has not been specified, the empty value corresponding to the attribute data type. In this case, the following warning will be given: Rgz0008: Attribute %1 changed from AllowNulls=Yes to AllowNulls=No and no initial value was specified. Null values will be treated as empty ones.
Besides, if the attribute belongs to a foreign key, changes in the foreign key constraint definition could cause the creation of Load Referential Integrity programs.

If a new attribute is defined in an existing table that doesn't accept null, the following warning is displayed during reorganization: Rgz0007: Attribute %1 does not allow nulls and doesn't have a default value. An empty default value will be used. If this new attribute is a Foreign Key, a new referential integrity constraint is also created. Consequently, if the default value assigned to this attribute does not exist in the referenced table, the reorganization will fail. This is noted in the following message: Reorganization may fail if table %1 has records and the key value %2 does not exist in table %3.
Considerations
As mentioned above, when a foreign key is a compound key (with more than one attribute) and nulls are allowed for any of its attributes, new references may be defined if the remaining attributes comprise a foreign key too.





"
10,Transaction levels,"https://wiki.genexus.com//commwiki/wiki?42569,Transaction+levels","Suppose an application must take into account that countries contain a set of cities.
GeneXus provides an easy way to represent a reality such as this of countries and cities.
It can be implemented by adding a second level to the Country Transaction.
Being in the Country Transaction, while positioned on the last attribute, right-click and select Insert Level.

A sublevel is opened. You can call it: City.
Now, there are two possible ways to name the attributes on the 2nd level.
If you type a dot, you will see that GeneXus suggests “CountryCity” as a prefix, that is to say, the Transaction name + the 2nd level name. You would only have to complete it by adding Id at the end, and you would have the name CountryCityId.
If, on the other hand, you type inverted commas you will see that GeneXus suggests the prefix “City,” the 2nd level name. You would only have to complete it by adding Id at the end, and you would have the name CityId.

This two-level Transaction indicates that each country has several cities and that each city belongs to only one country.

When you save your Transaction structure, GeneXus defines (or change if it is necessary) the Web Form for this Transaction. As you can see, for each country now you can enter a group of cities.

For every two-level Transaction, GeneXus determines that it has to create two physical tables:
One table arises from the first level, in this case, to record the countries, with CountryId primary key.
And another physical table, associated with the second level, in this case, to record the cities in each country.

Note that GeneXus creates a table called Country and another table called CountryCity in the database. The second table name is taken from the Transaction name plus the name you gave to the second level.
Now, look at the primary key of the second table. It is composed of two attributes: CountryId and CityId. This means that the unique identifier of the cities is composed of both attributes.
Videos
Transactions with more than one level
"
11,Referential Integrity,"https://wiki.genexus.com//commwiki/wiki?42576,Referential+Integrity+controlled+automatically+by+the+applications+generated+by+GeneXus","The Transaction objects generated by GeneXus carry out Referential Integrity controls.
Suppose you define the following Transactions:
Country
{
   CountryId*
   CountryName
}

Customer
{
   CustomerId*
   CustomerName
   CountryId
   CountryName
}
In consequence, the following tables will be created in the database associated with the application:

COUNTRY (CountryId, CountryName)
Primary Key: CountryId
CUSTOMER (CustomerId, CustomerName, CustomerAddress, CustomerGender, CountryId)
Primary Key: CustomerId
Foreign Key: CountryId (COUNTRY)
The fact that the CountryId attribute in the CUSTOMER table is a foreign key concerning the COUNTRY table establishes a relationship between both tables.
You can see this relationship in this diagram:

The simple arrow means that in the table the arrow is pointing to there is an instance for every instance in the other table (this means that there is only one country for each customer).
The double arrow means that in the table it is pointing there are several instances for every instance in the other table (this means that there are several customers for each country).
The relation between the COUNTRY table and the CUSTOMER table is said to be 1 to N (1 to many).
Reciprocally, the relation between CUSTOMER and COUNTRY is N to 1 (many to 1).
In GeneXus terminology, we say that there is a subordinate relationship between both tables. We say that:
COUNTRY is superordinated to CUSTOMER
CUSTOMER is subordinated to COUNTRY
Meaning that:
When a record is created or modified in the subordinate table (CUSTOMER), there must be a related record in the superordinated table (COUNTRY).
When a record is deleted from the superordinated table (COUNTRY), there must be no related records in the subordinate table (CUSTOMER).
In other words:
When a record is inserted or modified in the CUSTOMER table, the value entered in the foreign key attribute (CountryId) must exist as the primary key value in a record of the COUNTRY table.
When a record is deleted from the COUNTRY table, there must be no records in the CUSTOMER table whose foreign key values (CountryId) are equal to the primary key value of the record you want to delete.


"
12,Web Form,"https://wiki.genexus.com//commwiki/wiki?8057,Transaction+Web+Layout","When defining a Transaction object, a default Layout is automatically created by GeneXus to specify the way the user will access data in web applications. This Layout may be modified.
The edited screen that is finally saved will be the screen that will always appear. Note that all attributes present in the Layout must be previously declared in the Transaction Structure.
Suppose the following Transaction structure:

The default Web Layout will be generated as follows:

See also
Transaction Structure
Structure Editor
Delete Cascade


"
13,Apply Defaults Option,"https://wiki.genexus.com//commwiki/wiki?13720,Apply+Defaults+Option+%28for+Win+and+Web+forms%29","<!<a href='CDATA[p {
	margin-top: 0;
}
tbody {
	vertical-align: top;
}
'>CDATA[p {
	margin-top: 0;
}
tbody {
	vertical-align: top;
}
</a>]>
It allows applying the default form to several transactions at once.
Upon choosing the right option (for Win or Web), the Select Object dialog window will be displayed for you to choose the transaction(s) to which you want to apply the default form.
This option is particulary useful for KBs originating in previous versions, whose interface is to be renewed. Note that the conversion process does not renew the forms to keep compatibility.

Scope
Objects:
Transaction object


Interface:
Web, Win
See Also
Dynamism between Transactions and Patterns
Apply Default menu option (for Win and Web Forms)



"
14,General concept,"https://wiki.genexus.com//commwiki/wiki?8213,Transaction+rules","Rules play a very important role in Transaction objects, as they allow you to program their behavior (for example: assigning default values, defining controls over the data, etc.).
They are written in a declarative way, which means the order in which they are written is not necessarily the order in which they will be executed.
All Transaction rules can involve attributes of the Base Tables associated with the Transaction and most rules can also involve attributes of the Extended Tables of such base tables, but they must be included in the Transaction's structure.
Rules may involve not only the attributes included in the Transaction's structure, but also variables defined within the object, constants, and functions.
They are local, so they're only valid within the Transaction in which they are defined.
Some valid rules for Transactions are:
Conditional Rules
Unconditional Rules


Msg
Default


Error
Accept


NoAccept
Parm


Assignment
Serial


Add
NoPrompt


Subtract
Prompt


Color
RefCall


Call method or rule
RefMsg


Submit
Equal


 
Error_Handler


 
Update
See Also
Transaction Rules Syntax
Videos
Rules definitions
"
15,Error,"https://wiki.genexus.com//commwiki/wiki?6852,Error+rule","Displays an error announcement and does not allow continuing with the execution while the condition is complied with.
Syntax
Error('announcement' | &var | character_expression [,ExceptionName]) [ IF condition ] [ON triggering event];
Where:
'announcement' (or &var or character_expression)
         Is the phrase (string) you want to display when the condition is complied with.
        When using a variable or character_expression, GeneXus controls the resulting type is character (if not, it is adviced in the navigation report).
ExceptionName
         If the transaction is configured as Business Component, the ExceptionName parameter can be set as the ID of the error to solve Error handling in Business Components
condition
         Is any valid logic condition
triggering event
         Is one of the predefined events available in GeneXus for transaction rules, which allows you to define the precise time for executing a rule
Scope
Objects: Transaction
Samples
Example 1
Customer                  
{                                   
    CustomerId*         
    CustomerName   
    CustomerLastName
    CustomerAddress
    CustomerPhone
    CustomerBirthDate      
}
Customer rules:
error('Enter the customer name please') if CustomerName.isempty();
error('Enter the customer last name please') if CustomerLastName.isempty();
error('The customer must be 18 years old or older') if CustomerBirthDate.age()<18;
error('Customers can not be deleted') if delete;
Example 2
Suppose the Customer transaction is configured as Business Component and the transaction has the following rule defined:
error('The customer must be 18 years old or older', 'CustomerMustBe18YearsOld') if CustomerBirthDate.age()<18;
The value referenced in the ExceptionName parameter will be charged in the &Messages collection variable based on the Messages SDT (in the ""ID"" property) which you can load using the GetMessages() method.
Example code:
&CustomerBc is a Customer variable

&CustomerBc.save()
If &CustomerBc.Fail()
   &Messages = &CutomerBc.GetMessages()
    If &Messages.Item(1).ID = 'CustomerMustBe18YearsOld'
        .......
The ExceptionName parameter is an identifier, so it does not accept neither spaces, special characters: / : ” | = < > | nor Functions.
If the syntax is not correct, GeneXus will display the following compilation error:
xxx.cs(yy,yy): error CS0103: the name 'pushError' does not exist in the actual context.
Example 3
Working with the same Customer transaction, the following rule can be defined:
Error(&ReturnedText) if ProcedureCheck(&ReturnedText);
The previous definition is valid, but you must take into account that the variable &ReturnedText is considered a procedure input parameter. So, the rule will only be triggered if the variable is assigned (for example, if it is an output variable in another rule).
Note: When deleting a record from a Transaction, the rules won't execute unless you specify the condition ""if delete"".
See Also
Transaction rules
"
16,Msg,"https://wiki.genexus.com//commwiki/wiki?6854,Msg+rule","Displays a message as a notice or warning, but it doesn't prevent you from continuing working.
Syntax
Msg('message' | &var | character_expression [,ExceptionName]) [ IF condition ] [ON triggering event];
Where:
'message' (or &var or character_expression)
         Is the phrase (string) you want to display when the condition is complied with.
         When using a variable or character_expression, GeneXus controls the resulting type is character (if not, it is adviced in the navigation report).
ExceptionName
         If the transaction is configured as Business Component, the ExceptionName parameter can be set as the ID of the message to solve Error handling in Business Components
condition
         Is any valid logic condition
triggering event
         Is one of the predefined events available in GeneXus for transaction rules, which allows you to define the precise time for executing a rule
Scope
Objects: Transaction
Description
This rule is used to display a message as a notice or warning, with the possibility to continue working if the condition is complied with. In other words, it does not stop the process as it happens with the Error rule.
Samples
Example 1
Customer                    
{                                     
    CustomerId*           
    CustomerName     
    CustomerLastName 
    CustomerAddress
    CustomerPhone        
}
Customer Rules:
msg('The address is empty') if CustomerAddress.isempty();
msg('The phone is empty') if CustomerPhone.isempty();
error('Enter the customer name please') if CustomerName.isempty();
error('Enter the customer last name please') if CustomerLastName.isempty();
Example 2
Suppose the Customer transaction is set as Business Component and the transaction has the following rule defined:
msg('The phone is empty',CustomerPhoneIsEmpty) if CustomerPhone.isempty();
The value referenced in the ExceptionName parameter will be charged in the &Messages collection variable based on the Messages SDT (in the ""ID"" property) which you can load using the GetMessages() method.
Example code:
&CustomerBc is a Customer variable

&CustomerBc.save()
If &CustomerBc.Fail()
   &Messages = &CutomerBc.GetMessages()
    If &Messages.Item(1).ID = CustomerPhoneIsEmpty
       .......
The ExceptionName parameter is an identifier, so it does not accept neither spaces, special characters: / : ” | = < > | nor Functions.
If the syntax is not correct, GeneXus will show the following compilation error:
xxx.cs(yy,yy): error CS0103: the name 'pushError' does not exist in the actual context.
See Also
Message command
Transaction rules





"
17,Default,"https://wiki.genexus.com//commwiki/wiki?6850,Default+rule","Assigns a default value to an attribute or variable.
Syntax
Default(att | &var, expression);
Where:
att | &var
    Is the attribute or variable to be assigned.
expression
    Is any valid expression that can involve a procedure, function, method, constants, variables or other attributes (the result must match the attribute or variable type definition).
Scope
Objects: Transaction, Procedure, Web Panel
Description.
This rule is mostly used to initialize an attribute with a certain value, which can be modified, in a  Transaction object. Here, the rule is triggered only when the transaction is executed in Insert mode. When the transaction is executed in other modes like Update, Delete or Display, the attribute already has a stored value, and the objective of this rule is not to rewrite it.
Although this rule can be used in other objects with the same objective, its use is unusual because depending on the object, the variables may be initialized in different sections, like an event, source, etc.
Samples
Example 1
Customer
{
  CustomerId*      
  CustomerName         
  CustomerAddress      
  CustomerPhone   
  CustomerAddedDate 
  CustomerState
}
Customer Rule:
Default(CustomerAddedDate,today());
Note:
The behavior provided by the Default rule proposed in the example, is exactly the same as the behavior provided by the following rule:
CustomerAddedDate=today() if insert;
Example 2
The following example shows a rule defined in the Customer transaction, that uses the Previous function, to initialize the CustomerState attribute for a new customer which is being inserted (with the value of the previous customer).
Default(CustomerState,Previous());
In other GeneXus objects (like procedures or web panels), the Default rule can only be defined to initialize variables, and they will be triggered at the beginning of program execution. The expression in these cases, only allows 'literals' between quotes, numbers, and the following functions: Today(), Date() and Sysdate(). An example is shown next:
Default(&FirstCustomerId, 1);
Default(&LastCustomerId, 999);








"
18,NoAccept,"https://wiki.genexus.com//commwiki/wiki?6856,NoAccept+rule","Prevents the value of a field from being changed by end-user interaction. In most environments, this means the field is disabled (no end-user input is allowed) when the condition (if any) applies.
If user input cannot be disabled (Business Component, iSeries, for example), the input value is ignored.
Syntax
NoAccept(att | &var) [ IF condition ][ ON triggering event] ;
Where:
att | &var
   In Web Panel objects and Panel objects only variables are editable. So, in those objects, this rule can be used for variables. In Transaction objects, attributes are editable. So, mostly this rule is used for attributes. Variables are accepted in Transaction if you define Accept rules.
condition
   Is the condition that must be met to trigger the rule.
triggering event
   See Triggering events for rules in Transactions.
Scope
Objects:
Transaction
Web Panel
Panel
Work Panel

Generators:
.NET
.NET Framework
Java
Description
The NoAccept rule doesn´t allow the end-user to change the value of a field. In most Environments, this means that the field is disabled (no end-user input is allowed) when the condition (if any) applies. If user input cannot be disabled (Business Component, iSeries, for example), then that input value is ignored.
GeneXus evaluates which Attributes/Variables are used for input/output. However, there are times when you do not want the end-user to enter data for what GeneXus considers to be an input Attribute/Variable. This rule enables you to define which will not be used as input fields. The rule may also be used in combination with conditions.
All variables that appear in a Web Panel object or Panel object are always by default input variables (i.e. they accept input) unless a NoAccept rule has been defined for it. Hence, this rule indicates that the variable must not be accepted.
When you declare this rule, you will be able to assign a value for the attribute or variable with another rule.
Samples
NoAccept(ProductDescription);                             // Unconditional NoAccept
NoAccept(CustomerCreditLimit) if CustomerCategoryId = 1;  // Conditional NoAccept
Notes:
&var could be an SDT variable and in this case just writing NoAccept(&var) is enough to disable all the SDT elements.
Conditional Noaccept: You must be able to evaluate the condition before the attribute/variable in the NoAccept rule is entered. That is, the attributes/variables involved in the condition must have a value before the rule is triggered. Conditional NoAccept is only valid for Transactions.
NoAccept rule over Primary Keys does not apply to Business Components methods (Load, Insert, Update, InsertOrUpdate).
The NoAccept rule is expanded at specification time as {att|&var}.Enabled = 0 assignment for the No Accept condition and {att|&var}.Enabled = 1 for the otherwise section.
If you take the conditional rule of the previous example, you will see in the following code the Navigation view of the object:
One condition:
Rule:
NoAccept(CustomerCreditLimit) if CustomerCategoryId = 1;
Navigation View:
CustomerCreditLimit.Enabled = 0 If CustomerCategoryId = 1; 1 OTHERWISE;

More than one condition:
Rule:
NoAccept(CustomerDiscount) if CustomerDate > Today() and CustomerActive = false and CustomerAmount = 0;
Navigation View:
CustomerDiscount. Enabled = 0 IF CustomerDate > today() and CustomerActive = FALSE and CustomerAmount = 0; 1 OTHERWISE;
This means that the rule will disable the CustomerDiscount attribute only if the value of the attribute CustomerDate is < Today() and the value of the attribute CustomerActive = false and the value of the attribute CustomerAmount = 0, otherwise it will remain enabled.
If you have different conditionals NoAccept, you must be careful with the conditions defined in each one, as they can cause conflicts between them.
See Also
Enabled property

"
19,Serial,"https://wiki.genexus.com//commwiki/wiki?6866,Serial+rule","Numbers a Transaction object’s second, third, or another nested level, automatically.
Syntax
Serial(att1 , att2 , step);

Where:

att1
     Is the attribute to be increased.

att2
     Marks the starting value for att1 and is always updated with the last value of att2. This attribute must be included in the structure level that is immediately above the attribute you wish to autonumber. You can delete att2 from the form, but the attribute att1 is required to be on the web form, otherwise the rule will not work on the client-side.
step
     Is the value to add to each att1. In other words, is the serialization step or increment.
Description
You need to use this rule to automatically number a second, third, or another nested level, as the Autonumber property can only be applied to single primary keys.
This rule requires defining an attribute in the first level of the Transaction, which will save the last value assigned to the lines of the second level.
Samples








"
20,Assignment,"https://wiki.genexus.com//commwiki/wiki?6847,Assignment+rule","Updates the database by assigning a value that results from evaluating an expression, a fixed value or a value stored in an attribute/variable to an attribute or variable.
Syntax
att | &var = expression [ If condition ]   [ on triggering event];
Where:
att | &var
    Is the attribute or variable to be assigned. In the case of being an attribute, it cannot be a formula.
expression
    Is any valid expression that can involve constants, functions, procedures, variables, or other attributes (the result must match the attribute or variable type definition).
condition
    Is any valid logic condition (that can contain the ""and"", ""or"", and ""not"" logical operators).
triggering event
    Is one of the predefined events available in GeneXus for transaction rules, which allows you to define the precise time for executing a rule.
Scope
Objects:
Transaction

Generators:
.NET
.NET Framework
Java
Samples
Consider the following Transaction object:
Customer
{
  CustomerId*      
  CustomerName         
  CustomerAddress      
  CustomerPhone   
  CustomerAddedDate 
  CustomerLastUpdateDate
}
Now observe the following rules defined in that Transaction to assign values to certain attributes and variables:
CustomerAddedDate = today() if insert;
CustomerLastUpdateDate = today();
&DiscountPercentage=10 if CustomerAddedDate.year() < 2011;
See Also
Assignment command for variables
Assignment command for attributes



"
21,Add,"https://wiki.genexus.com//commwiki/wiki?6845,Add+rule","Adds the value of one attribute to the value of another attribute, if you are inserting.
Subtracts the value of one attribute to the value of another attribute, if you are deleting.
Calculates the difference between the new and old value of the attribute you update and that difference is added to another attribute if you are updating.
Syntax
Add(att1 , att2) [ if cond ] ;

In mode:
Insert: the value of the att1 attribute is added to the value of the att1 attribute (if the specified condition is true).
Delete: the value of the att1 attribute is subtracted from the value of the att2 attribute (if the specified condition is true).
Update: the difference between the new and old value of the att1 attribute is added to the value of the att2 attribute (if the specified condition is true).
Samples
Consider the following Transaction objects:
Customer                              Trip                           Country   
{                                     {                              { 
    CustomerId*                          TripId*                       CountryId*
    CustomerName                         TripDate                      CountryName
    CustomerLastName                     CountryId                     City
    CustomerPhone                        CountryName                   {
    CustomerTotalMiles                   CityId                          CityId*
    Trip                                 CityName                        CityName
    {                                    TripMiles                     } 
      TripId*                          }
      TripDate                                                       }
      CountryId
      CountryName
      CityId
      CityName
      TripMiles
    }
}
Suppose that a customer makes several trips and accumulates miles.

To implement the customer’s mileage accumulation, you define the following rule in the Customer Transaction:
Add(TripMiles, CustomerTotalMiles);
The following behavior is incorporated into the Add rule:
If a new trip is added for the customer, the value of TripMiles is added to CustomerTotalMiles.
If a trip is deleted from the customer, the value of TripMiles is subtracted from CustomerTotalMiles.
If the value of TripMiles associated with a customer’s trip is changed, its configured value is automatically subtracted and the new value is added to the customer’s total miles.
See Also
Subtract rule


"
22,Subtract,"https://wiki.genexus.com//commwiki/wiki?6860,Subtract+rule","Subtracts the value of one attribute to the value of another attribute when inserting.
Adds the value of one attribute to the value of another attribute when deleting.
Calculates the difference between the new and old value of the attribute you update and that difference is subtracted from another attribute when updating.
Syntax
Subtract(att1 , att2) [ if cond ] ;
In mode:
Insert: the value of the att1 attribute is subtracted from the value of the att2 attribute (if the specified condition is true)


Delete: the value of the att1 attribute is added to the value of the att2 attribute (if the specified condition is true)


Update: the difference between the new and old value of the att1 attribute is subtracted from the value of the att2 attribute (if the specified condition is true)
Samples
Customer                              Trip                      Prize                    Country  
{                                     {                         {                        {
    CustomerId*                          TripId*                  PrizeId*                  CountryId*
    CustomerName                         TripDate                 PrizeDate                 CountryName
    CustomerLastName                     CountryId                PrizeDescription          City
    CustomerPhone                        CountryName              PrizeMiles                {
    CustomerTotalMiles                   CityId                   CustomerId                  CityId*
    Trip                                 CityName                 CustomerName                CityName
    {                                    TripMiles                CustomerTotalMiles        }
      TripId*                          }                        }                         }
      TripDate                                                                     
      CountryId
      CountryName
      CityId
      CityName
      TripMiles
    }
}
The Prize Transaction allows defining rewards to be traded for miles.
Each prize requires a number of miles to be assigned to a customer who has accrued that number of miles (or who has an even larger number of miles). Therefore, when trying to assign one customer to one prize, you must check if the customer has enough miles to be able to assign this prize. If the customer has enough miles and accepts the prize, you must subtract the traded miles. If the customer doesn’t have enough miles, you need to show an error message.
In the Prize transaction the two following rules were defined:
Subtract(PrizeMiles, CustomerTotalMiles);
Error(“Customer doesn’t have enough miles accrued”) if CustomerTotalMiles < 0;
The following behavior is provided by Subtract rule:
If a new prize is inserted, the value of PrizeMiles is subtracted from CustomerTotalMiles.
If a prize is deleted, the value of PrizeMiles is added to CustomerTotalMiles.
If the value of PrizeMiles is changed, its old value is automatically added to the customer’s total miles and the new value is subtracted from the customer’s total miles.
Since the Subtract and Error rules involve the CustomerTotalMiles attribute and one of the rules updates the attribute while the other one assesses its value, GeneXus determines that first, it must make the subtraction that updates the CustomerTotalMiles attribute and after that, it evaluates what happened with its value.
As the subtraction is made first, if the customer has fewer miles than those required by the reward, the CustomerTotalMiles attributes will have a negative value. For this reason, the Error rule evaluates if CustomerTotalMiles<0. If this happens, the Error rule is triggered, the error message is displayed and the subtract rule is undone; that is to say, its execution is reverted as if nothing was done and the customer’s total number of miles is not modified.
If CustomerTotalMiles doesn’t have a negative value (CustomerTotalMiles<0) after making the subtraction, it means that the subtract operation has been performed.
Note that if the record of a prize assigned to the customer is deleted, the subtract rule adds instead of subtracting. That is to say, it adds the number of miles corresponding to the reward (PrizeMiles), to the total number of miles accrued by the customer (CustomerTotalMiles).
See Also
Add rule







"
23,Update,"https://wiki.genexus.com//commwiki/wiki?21430,Update+rule","Edits/updates attributes that are not stored in any of the base tables of a Transaction object.
Syntax
Update(att1, ..., attn);
Where:

att1, ..., attn: attributes belonging to the Extended Table.
Scope
Objects:
Transaction object
Description
This rule allows you to edit or update attributes that are not stored in any of the base tables of a Transaction object.
Given a Transaction level, the only attributes that can be edited are the ones stored in its Base Table. For example, in an Invoice Transaction you can have the CustomerName in the form, but it isn't editable; the only Customer attribute that can be edited in the Invoice form is CustomerId, because it is stored in the Invoice table.
The Update() rule is introduced in case you need to edit CustomerName anyway in the Invoice form.
This rule is unconditional. Therefore, to conditionally allow the edition of a particular attribute, you should combine it with the NoAccept rule.
Samples
The following example explains the canonical use of the Update rule. Suppose you have a Customer Transaction, an attribute called CustomerAddressLastShipment inside it, and an Invoice Transaction, too.
Invoice
{
    InvoiceNumber*
    InvoiceDate
    CustomerId
    CustomerName
    CustomerRUT
    CustomerAddressLastShipment
    InvoiceLastNumber
    }
         ProductId*
         ProductDescription
         ProductPrice
         InvoiceLineQtty
         InvoiceLineTotal
    }
}
Customer
{
    CustomerId*
    CustomerName
    CustomerRUT
    CustomerAddress
    CustomerAddressLastShipment
    CustomerMail
    CustomerBalance
    CustomerPhone
}
The CustomerAddressLastShipment attribute is inferred from the Customer table and it is displayed on the screen in a read-only mode. However, if the shipping address changed, this rule could solve it.
Update(CustomerAddressLastShipment);
The operator may change the address, and this new information will be stored in the Customer table.

Considerations:
Transactions may have either one or more Update rules. There is no preferred method for writing them.
No errors or warnings are raised for this rule (i.e. reference to attributes that can already be accepted).
Some considerations about the rule's behavior in Update mode:
If the foreign key determining the inferred attribute can be changed (i.e. it does not belong to the primary key of the base table) and it is changed in different transactions (work units), the value of the inferred attribute for the ""original"" foreign key value is not restored. An example may clarify the concept:
Suppose you have two Transactions: Customer and Invoice, which are related. CustomerCod is a Foreign Key (FK) in the Invoice and it has this rule:
Update(CustomerName);
It has an Invoice #1 with CustomerCod = 1 whose CustomerName = ""Customer_x"". The CustomerName value is changed (in fact, CustomerName is updated in the Customer's table) in Invoice #1 to ""Customer_new"" and the Invoice is confirmed.
After that (in a new LUW) the CustomerCod for invoice #1 is changed to another value, for example, CustomerCod = 2. This change doesn't mean the Customer #1 Name is restored to its original value.





"
24,Parm,"https://wiki.genexus.com//commwiki/wiki?6862,Parm+rule","Declares the list of parameters that a GeneXus object receives from the object(s) which invoke(s) it.
Syntax
Parm([in:|out:|inout:]parm1, …, [in:|out:|inout:] parmN);
Where:
in: | out: | inout: 
    Are operators which allow defining for each parameter, how it is going to be used in the called object (in, out, inout).
parm1, ..., parmN:
   Are variables or attributes that are defined in the called object. For each parameter received, you can decide whether you declare it as an attribute or a variable, regardless of how it was sent.
Description
When an object is called from another object with parameters, the set of parameters received must be declared inside the Parm rule in the called object, respecting the order and the data type as they were sent, each one separated by a comma. In addition to this, for each parameter it is optional to point out how it is going to be used (in, out, inout).
If the object was invoked with Call, and N parameters were transferred, the N parameters must be declared in the parm rule. However, if the object was invoked with the Udp method and unless it was invoked in a Data Provider), bear in mind the following:
N + 1 parameters must be declared in the parm rule of the called object.
The last parameter declared in the parm rule corresponds to the value which is returned (in other words, corresponds to the value received in the caller object).
A value must be assigned to the returned (the last) parameter somewhere in the called object.
Considerations:
As they receive parameters and they must be called with the parameters' values, none of the objects that have a Parm rule defined are included in the Developer Menu.
Parameters do not receive a null value. If a null value is sent in a parameter, the called program receives an empty value.
Variables that are in a Parm rule are set as read-only by default when they are put in a form of a Web Panel object or Transaction object.
The difference between using a variable on an at or an attribute in the Parm rule of the invoked object lies in the fact that If you receive the value in a variable, it may be used freely in programming, as a filter condition for equality (higher than, greater than or equal to, lesser than, lesser than or equal to), for some arithmetical operations, or whatever you may need to do with it. On the other hand, if you receive the value in an attribute, it will automatically act as a filter for equality in the object.
If your objective is not to use a value received to filter for equality, then the only solution possible is to receive the values in variables to use them freely.
Samples
The following codes, show two ways of filtering for equality the same information. The result and performance of both solutions are equal.

Example 1
Suppose you define a Web Panel for the user to enter a start and end range of names of attractions to be listed.

As the image shows, two variables and a button are present in the Web Panel form (the default Caption -Confirm- and the default event -Enter- are kept for the button). In the Enter event associated with the button, you have to call the Procedure object that prints the attractions that their names are included in the range indicated by the user.
The Procedure will receive the start and end range of names of attractions, and you have to use the range received to filter the requested attractions.
This is the invocation defined in the Web Panel:

And this is the Parm rule declared in the Procedure:

Note that the variables are named differently regarding the names defined in the Web Panel. What it is important is that the data types sent and received match.

The variables you receive in the Procedure will be used to filter the requested attractions. The following image shows the Procedure Source section, with the code that solves the requirement and using the received variables to filter:

Note: This Procedure has the necessary properties and rules to print the output in a PDF format.
Example 2
See the proposed examples in the following articles:
Call method
Udp method
Related specification messages
spc0068 when a parameter has a data type that cannot be used for parameters in certain circunstances.
spc0023 for each parameter in the call command having a data type that is not compatible with the correspondig in the parm rule
spc0024 if there are too few parameters in the call command
spc0025 if there are too many parameters in the call command







"
25,Triggering events,"https://wiki.genexus.com//commwiki/wiki?6840,Category%3ATriggering+events+for+rules+in+Transactions","The rules you define in a Transaction object are usually executed when you expect it. But in some cases, it may be necessary to modify that moment in time.
Most transaction rules allow you to add a triggering event or moment to them, indicating when each of them must be exactly executed.
Syntax
Any valid Transaction rule [ IF condition ][ ON triggering event] ;
Where:
condition
         Is any valid logic condition
Available triggering events
The following triggering events are available to be added at the end of most transaction rules:
BeforeValidate / BeforeInsert / BeforeUpdate / BeforeDelete / BeforeComplete
AfterValidate 
AfterInsert / AfterUpdate / AfterDelete
AfterLevel Level
AfterComplete
Videos
Rule Triggering Events in Transactions
"
26,Start event,"https://wiki.genexus.com//commwiki/wiki?8043,Start+event","Defines an action to be performed when the object starts running. It is a system event that takes place when an object starts running. It is commonly used to assign values to variables that, during the object's execution, will be used by counting operations or by other events, for example.  Web Panels generally use this event to place default values in the 'fixed area' of the form.
In Web interfaces, the Start event is executed when the page is loaded (get) and with every post to the server.
In mobile apps, it is executed only the first time a Panel object or a Work With pattern and Work With object node is opened on a device. It is not executed again unless the panel is exited and opened again.
Syntax
Event Start
        Event_code
EndEvent

Where:
Event_code
   Code associated with the event.
Examples
If you need to control access to the transaction, you could call a Procedure object:
Event Start
   ChkSecurity.Call(&WebUserExtKey, &WebUserLogin, &aUserProfiles(), &aUserRights(), &Message)
   if not Null(&Message)
      Call(ShowMessage, &Message)
   EndIf
EndEvent
The Start event is used to assign the &Date variable with the value indicated by the current date before the Web Panel is displayed. This ensures that the current date can be properly shown when the panel is displayed. This technique is very useful to assign default values.
Event Start
    &Date = Today()
EndevEnt
The organization's name will be displayed at the start of the Transaction's execution:
Event Start
   &OrgName = GetOrgName.Udp(OrgCode)
EndevEnt
What this UDP does is call the Procedure called GetOrgName which returns the name corresponding to the Organization's Code (OrgCode) which has been passed as parameter and assigns it to the Organization name variable (&OrgName).
Scope
Objects: Transaction object, Web Panel object, Panel object,Work With pattern and Work With object






"
27,User defined,"https://wiki.genexus.com//commwiki/wiki?8044,User+defined+event","Apart from the standard GeneXus events, you can define your own specific events called User defined events.
A User defined event triggers an action whenever a key or button is pressed, or when an Action is selected from the Action Bar.
The shortcut key combination associated with the user event is optional, If no shortcut key is defined, the only way that the event is triggered is when user presses the associated button.
Syntax
Event user_event_name [key ]
EndEvent

Where:
user_event_name
  Name of the user event

key
  Number of function key associated with the event. Optional.
Examples
Web Panel
You could have defined the following:
Event 'Create Supplier' 6
    &No = 0
    CreateSupplier.Call('INS',&No)
    refresh
EndEvent
This is a user-defined event called 'Create Supplier', and F6 will be the shortcut key that will trigger the Create Supplier event. This event calls the Suppliers transaction, which receives as parameters the Insert mode and a numeric variable whose assigned value is equal to 0. After calling the Transaction, the Refresh command is executed, indicating that the grid must be loaded again, since a new supplier has been added (otherwise the newly inserted supplier will not be displayed because this data did not exist when the first load was executed).
Transaction
Prints an invoice by pressing the corresponding button associated with the event.
Event 'Print Invoice'
    PrintInvoince.Call(InvoiceNumber)
Endevent
In Transactions you may select the level at which the event will be triggered by means of the Level Sentence.
Scope
Objects   Transaction object, Web Panel object
See also
Global Events 
Level Sentence (only to be used in Transactions).


"
28,After Trn,"https://wiki.genexus.com//commwiki/wiki?8045,After+Trn+Event","To define an action to be executed after each Transaction’s cycle.
Syntax
Event After Trn
        Event_code
EndEvent
Where:
Event_code
    Code associated with the event.
Description
This event is activated once the transaction has ended a cycle;  that is: immediately after Commit.
Examples
You may want to return to the calling program after entering a transaction:
Event After Trn
    Return
EndEvent
To print a card with the transaction during a Transaction session, and to update the last operation in a log file system, you could program the following events:
Event After Trn
     PrintAirlineCard.Call(AirlineId)
     UpdateLogAirline.Call(AirlineId, &TimeEnter, &TimeExit)
EndEvent
Scope
Objects: Transactions
Languages: .NET, Ruby, Java, RPG, Visual Basic, Visual FoxPro, Cobol
See Also
AfterComplete Event



"
29,Exit,"https://wiki.genexus.com//commwiki/wiki?8046,Exit+event","To define an action that will be executed upon the finished object.
Syntax
Event Exit
	        Event_code
	EndEvent
Where:
Event_code
	    Code associated with the event.
Description
This event takes place after the user exits the object (by clicking the control associated with the event) or the return command executed.
Scope
Objects

Transaction object



Interfaces

				Win









"
30,TrackContext,"https://wiki.genexus.com//commwiki/wiki?8051,TrackContext+event","What do we understand by context? When we talk about Context, we mean the context of our application in a form.
When we move inside a screen, we're changing the context of attributes and variables. This information about context changes is essential to create an intent-oriented interface.
Our approach enables you to trigger events and take actions depending on the context information of our application (the place where the cursor is positioned).
This is why we say that the User Interface (UI) is context-sensitive, giving more power to the final applications.
Suppose that the application consists of several web components which make up the web form. You can easily trigger an event in one of the web components as soon as the end user changes his/her context information in another component (changes the focus to a control, or selects a grid line).
Basically, the web controls that you want to track changes on ""subscribe"" to an event which listens to the context changes of any other control.
Defining a TrackContext event, allows you to retrieve the context information and take the desired actions.




Syntax
Event TrackContext (parameters)
      Event_code
EndEvent
Where:
Event_code 
    Code associated with the event.
The parameters can only be variables.
Description
The event is qualified by the parameters it receives; that is: you can have any number of TrackContext Events in your source code, that are differentiated by the parameters they receive.
Scope
Objects:
Transaction, Web Panel


Generators:
.NET, .NET Framework, Java
See also
Context Sensitive User Interfaces







"
31,General concepts,"https://wiki.genexus.com//commwiki/wiki?2814,Category%3APatterns","When developing applications, you can note that some application parts are quite similar but not exactly the same. For example, in an application involving Customers and Products, it is only natural to have a Form to list Customers, and another Form to do the same for Products. Even though Customers and Products are totally different, these two Forms have many things in common: a grid, a fieldset to filter data, ordering, actions, etc.
This is called a ""pattern"" and has been a very popular topic in the software industry lately (see What Is a Software Pattern for more info).
These ideas are considered in GeneXus. So, what exactly is a pattern in GeneXus? And why is it useful? Before answering these questions, you must first address some of the limitations of patterns today:
Passive. They exist only in books; the only way to use them is to read the books and use these ideas while coding.
At coding level. Even though patterns are usually referenced as ""Design Patterns"", they are mainly aimed at helping with coding.
Since GeneXus works at knowledge level instead of coding level, patterns are used as a way to enable knowledge reuse, not just code reuse. So, GeneXus offers a framework for patterns whose design goals are as follows:
Active. An ""active"" pattern isn't just a guideline; you can ""instantiate"" it (meaning that the framework generates all the GeneXus objects needed to implement a pattern instance). See the Pattern Instantiation concept.
Knowledge reuse. GeneXus has always tried to encourage knowledge reuse, but with the use of patterns you can deliver a new level of knowledge reuse: the same knowledge can be reused in many different situations. For example, a ""specialized pattern"" can be instantiated to Products, but also to Menus.
Open. Anyone can generate his/her own patterns (or modify an existing one).
Developer-friendly. To use a pattern you don't need to be an expert in this area. (Note: If you also want to develop your own pattern, a deeper knowledge of the subject is needed).
GeneXus Patterns are the result of these efforts. This extension is included in the GeneXus IDE and if you define a new Pattern you will also view it as a new option in the GeneXus IDE.
The extension itself comes with a set of ""built-in"" patterns such as Work With Patterns and others so the developer can start using patterns without the need to develop a pattern him/herself.
The framework also helps developers create their own patterns.
After you define your Pattern structure the Pattern engine generates typed classes of your instances to use in the templates and in your custom code.
Why and When to Use a Pattern
Going back to the question of why Patterns are useful for a GeneXus developer: a big boost in productivity and application quality is expected with the use of this tool. For example, a typical use scenario is when developers need to migrate a Knowledge Base from green screen or Windows forms to Web forms. In this case the Work With Patterns can be applied to generate most of the web objects needed for a nice-looking and user-friendly web application.
See People And Organizations Knowledge Base for an example.
How Do Patterns Work?
Patterns are fully integrated into the GeneXus IDE. GeneXus has built-in Work With and others.
The implementation is based on the built infrastructure to create defaults for each object part. Basically, this means that now you don't need to apply the pattern and import the result. When you change a property in the pattern definition, objects will automatically react to the change without the need to recreate them.
Every part of every object can have a default value. You can have default Web Panel forms, Web Panel events, etc. The default for each part can be different for each specific object. You can have a Web Panel with one template set as default for the form, and another with a different one.
The Work With Patterns implementation creates a set of empty objects with specific default templates set in each object. It creates a “WW<Transaction>"" Web Panel with a default template that reads the transaction structure and creates a grid. This means that every time you add an attribute to the transaction, it will also be added to the Web Panel without the need to apply the pattern again.
Documentation
Applying Patterns
Dynamism between Transactions and Patterns
Pattern settings
Deleting Pattern Instances
Built-in Patterns
Working on large KBs and multiple Pattern instances
Creating a New Pattern
Creating a Fork of the Work With Pattern
Debugging options for Patterns
Patterns Gallery
Videos
Using Patterns
"
32,Work With Patterns,"https://wiki.genexus.com//commwiki/wiki?5636,Work+With+Patterns","The Work With Pattern is one of the best-known and most useful patterns in business applications.
It was first popularized by IBM and was rapidly adopted by GeneXus.

It is a User Interface pattern based on 'Object Action Dialogs', where users first select an object from a list to ""work with"" it and then apply an action to it.

In particular, the GeneXus Work With Pattern is embedded in GeneXus so that you can easily apply it and quickly obtain a complete application that allows searching, showing, ordering data, and performing actions like queries, insertions, updates, and deletions.
Depending on the kind of application, you can apply these Work With patterns:
Web (non-Angular) apps: Work With for Web pattern
Native Mobile and Angular front-end apps: Work With pattern
"
33,Work With for Web pattern,"https://wiki.genexus.com//commwiki/wiki?25475,Work+With+for+Web+pattern","To apply the Work With for Web pattern to a Transaction object select the Patterns tab and then choose the Work With for Web tab.
You only have to click on the Apply this pattern on save checkbox and save.
After that, if you look for the Transaction in the KB Explorer, you can see that several objects are located below the Transaction. They are created by GeneXus when the Work With for Web pattern is applied.

Instance Nodes
The following nodes are present in every Work With for Web pattern instance (and their properties by default are set with the values indicated in the Work With for Web Pattern Settings):
1) Root Node

It has the following properties (accessed through the Properties window):

Web Form Defaults property
Update Transaction property
Navigation Group: It has the following properties: 
	
AfterInsert
AfterUpdate
AfterDelete
These properties allow indicating the layout to which you want to go to after performing an insertion, an update, or a deletion, respectively. For each of these properties, there is a combo box that offers the values:
<default>
 <return to caller>
 <go to view>
 <go to selection>
2) Level Node
The instance will have one Level node for each Transaction level:
Each of these nodes has the following properties:
Name: The default value of this property is the level's base table.
Description: Describes the node.
And the following sub-nodes:
2.1) Description Attribute
It defines the Transaction's Description attribute.
Since this attribute will have a link, it can only be an Edit type attribute (that is, it cannot be a Combo or checkbox).
2.2) Selection
See Work With for Web Selection Node.
2.3) View
See Work With for Web View node.
Objects generated by the Work With for Web pattern
The Work With for Web pattern will generate the following objects for each Transaction to which is applied:
1) Work With Web Panel
It's a Web Panel object with a grid that lists all the records in a table and includes the following features:
Paging
Conditional Filters
Multiple Orders
Control Info for Filter Attributes
Standard Actions
Export to Excel
Save Grid State
2) View Web Panel
It's a Web Panel object that shows all the information of a record that has been selected in the grid of a Work With Web Panel. It shows the record's data in a tab, and also shows one tab for each subordinated table, containing a grid with the related information.
3) Optional Features
Context management
Object level security
The generated objects are automatically generated and called as follows:
WW<TransactionName> 

	
Sample: WWCategory.
It's the Web Panel object with a grid generated from the first Level node definition.


View<TransactionName> 
	
Sample: ViewCategory.
It's the Web Panel object that shows all the information of a record that has been selected in the grid of the WW<TransactionName> Web Panel.


<TransactionName>General

Sample: CategoryGeneral.
Is a WebComponent associated to the View<TransactionName> General Tab.


<XXX>WC 
	
Sample: CustomerWC.
A WebComponent with this name is generated for each Grid-type Tab.
Work With for Web pattern features
The Work With for Web pattern features are the following:
A Responsive Web Applications is automatically generated for Transaction objects and Web Panel objects for listing, searching and ordering data.
Web objects comply with the Web Smooth UX.
Controls supported by the Web Abstract Editor such as Action Group Control for the Web and Tab control for Web Panels.
The design proposed by Unanimo Design System is applied.  
Responsive Web Design apps are generated.
The Web Form Defaults property should be set to Responsive Web Design. Otherwise, check the compatibility notes below.
Compatibility Notes
For compatibility reasons, the Work With pattern template generates different layouts depending on the Theme / Design System configured.
If Web Form Defaults property is set to Responsive Web Design and Default Form Layout property = Unanimo Template, the default layouts use the Unanimo Design System. See Also Default Master Page property.
If Web Form Defaults property is set to Responsive Web Design and Default Theme property is Carmine (or a save as of it), the default forms use the Carmine Theme for GeneXus 15, GeneXus 16, GeneXus 17 until GeneXus 17 upgrade 4.
If Web Form Defaults property is set to Responsive Web Design and Default Theme property is different than Carmine (or a save as of it), the default forms are equal to the ones generated for X Evolution 3. 
Otherwise, if Web Form Defaults property is set to ""Previous Version Compatible"", the generated objects won't be Responsive, and the layouts are equal to the forms generated for X Evolution 2.
See Also
Work With for Web Pattern Settings (to see what the general settings related to all instances are).
LightCRM sample for a RWD implementation of this pattern.
"
34,Work With pattern,"https://wiki.genexus.com//commwiki/wiki?15974,Category%3AWork+With+pattern+and+Work+With+object","After applying the Work With Pattern to a Transaction object you can access, edit and configure the WorkWith<TransactionName> object.
In the image below, the Work With Pattern has been applied to the ""Property"" Transaction, so the ""WorkWithProperty"" object has been generated:

You can access the WorkWith<TransactionName> object in two ways:
1) In the KB Explorer, under the Transaction involved, you can open the WorkWith<TransactionName> with a double-click. 
2) Open the Transaction involved, select the Patterns selector, and then click on the ""Work With"" tab.
The image below shows the ""WorkWithProperty"" object opened:

WorkWith<TransactionName> object Nodes
1) List
It is the list on which the end user will be working. Conceptually, what is associated with a list is a Panel object that contains a grid with the data. Over this panel, there is a default Action that basically indicates that when a record of the List is selected, its Detail has to be displayed.
It is possible to apply filters, orders, and searches to lists.

There are also several ways to show the data and it is even possible to perform actions on the records list.
Since conceptually it is just a Panel, the same elements of a Panel are available: Actions, Conditions, Layouts by platform, etc.
Read more at Work With List Node.
2) Detail
It's the Panel object in which the selected record details will be displayed.
For example, when looking at a properties list and selecting one, it gives access to:
Detailed info about the record.
Related information (e.g. appointments).
Actions (schedule a visit, send an email to the real estate firm offering the property, approve orders, etc.)
Read more at Work With Detail Node.
3) Sections
When displaying a set of data and its relations, there's always the problem of how to show this data in an ordered manner that the end user can understand. For this reason, the Work With Pattern provides the Section concept in a Detail.
When using Sections, you must have a way to organize them within a Detail. To do so, in the Detail Layout you can make reference to one or more sections.
Given that the Detail allows multiple Layouts per platform, it may happen that some sections are displayed on one platform but not on another.
Read more at Work With Section Node.
Generated application
The following image shows the generated application as a result of having applied the Work With Pattern to the Property Transaction:

See Also
Applying Work With Pattern
Work With Pattern instance for Multi-level Transactions
Work With Pattern Settings
"
35,Dynamism between Transactions and Patterns,"https://wiki.genexus.com//commwiki/wiki?6622,Dynamism+between+Transactions+and+Patterns","All objects generated by Patterns are created with default parts, meaning that every part (form, rules, events, variables) of every object is generated by default. This is represented by the following icons:

If you change some part of the object, the icon will change as well:

The implementation based on default parts provides dynamism between the Transaction and the Pattern.
This means that when you change a property in the pattern definition, add a new filter in the instance, or make a change in the Transaction, all objects generated by Patterns will automatically react to the change without the need to reapply the pattern.
For example, the Work With Patterns implementation creates a set of empty objects with specific default templates set in each object. It creates a ""WW<Transaction>"" Web Panel with a default template that reads the Transaction structure and creates a grid.
Suppose you have a Customer Transaction with the following attributes:
Customer
{
    CustomerId
    CustomerName
    CustomerAddress
}
When you apply the Work With for Web pattern to this Transaction, you will obtain the following WWCustomer Web Panel:

Every time you add an attribute to the Transaction structure, it will also be added in the Transaction's instance and in the Work With Web Panel without the need to apply the pattern again. You only need to open the Work With Web Panel to see all the new attributes in the grid.
In the example, if you add a CustomerEmail attribute in the structure of the Customer Transaction:
Customer
{
    CustomerId
    CustomerName
    CustomerAddress
    CustomerEmail
}
When you save the Transaction, the attribute will be automatically added in the Transaction's instance and in the Work With Web Panel. When you open the objects, you can see the new attribute:


The dynamism between the Transaction and Pattern remains for all the default parts of the objects.
If you modify the Web Layout of a WW (it does not remain as default) and add a new attribute to the Transaction, the attribute will be automatically added in the Transaction's instance but not in the Work With Web Panel grid.
If you want to have default parts again you can select:
1) Edit (in the Main Menu) > Apply Default. Restores the default values of the part (Rules, Events, Conditions, etc.) where you have opened the object.
2) Edit (in the Main Menu) > Apply Default (All parts). Returns all the parts that have been modified to default.

"
36,Base Table,"https://wiki.genexus.com//commwiki/wiki?6347,Base+Table","A base table is any table in the database where you are positioned and working at a certain time, for example for retrieving or modifying its data.
When you execute a Transaction object with a single level, it has one associated base table.
When you work with a Transaction object with more than one level, each level has an associated base table.
Also, when you define queries (a listing, for instance), you will be navigating a specific base table.
Some examples:
For each command: The base table of a For Each is the table navigated, as determined by GeneXus. Even though a For Each doesn’t navigate only one table, but also an Extended Table, the For each has a base table that is navigated, and its Extended Table is accessed to retrieve or update data (or filter by an attribute that belong to the extended table, etc.).
New: Every time GeneXus finds a “new” command, it must identify the table where the record will be inserted. The table identified to make the insertion in it is the base table in this case.
Data Provider: The base table of a Data Provider is the table navigated to charge a collection, or an instance in memory, etc. Even though a Data Provider doesn’t navigate only one table, but also an Extended Table, the Data Provider has a base table that is navigated and its extended table is accessed (for the purpose of retrieving data or filtering by an attribute that belong to the extended table, etc.).
Grid: The base table of a grid is the table navigated to retrieve and display in the grid the required attributes. Even though not only one table is browsed, but also an Extended Table, the grid has a base table that is navigated, and its extended table is accessed (for the purpose of retrieving data too or filtering by an attribute that belongs to the extended table, etc.).
Formula: The base table of a formula is the table that is going to be navigated in order to evaluate it (to calculate its result value).
Subtype Group object: The base table of a subtype group is the table whose complete primary key is included in the subtype group definition, as the key of the group (the subtype group must include a subtype attribute or a set of subtype attributes, whose corresponding supertype attributes make up the primary key of an existing table, which it is the base table of the group).
See Also
Extended Table
Videos
Base and Extended table
"
37,Extended Table,"https://wiki.genexus.com//commwiki/wiki?6029,Extended+Table","The extended table of a given Base Table is a virtual table composed of the base table itself plus all the tables which have N-1 relations, either directly or indirectly, starting from the given base table.
For example, if you have the following Bachman Diagram:

The INVOICES base table will have the following extended table: {INVOICES, CUSTOMERS, COUNTRY}
The CUSTOMERS base table will have the following extended table: {CUSTOMERS, COUNTRY}
The COUNTRY base table will have the following extended table: {COUNTRY}
In its extended table, the INVOICES base table contains, in addition to itself, the CUSTOMERS table and the COUNTRY table. This is because starting from the INVOICES table (base table) there is an N-1 relation with the CUSTOMER table, and starting from the CUSTOMER table there is an N-1 relation with the COUNTRY table. Note that if you take one record from INVOICES, you find only one record from CUSTOMER related to it (and no more than one); and if you take one record from CUSTOMERS, you find only one record from COUNTRY related to it (and no more than one).
Following the same reasoning, in its extended table, the CUSTOMER base table contains, in addition to itself, the COUNTRY table. This is because starting from the CUSTOMER table (base table) there is an N-1 relation with the COUNTRY table. Note that if you take one record from CUSTOMERS, you find only one record from COUNTRY related to it (and not more than one).
The COUNTRY base table only contains itself in its extended table. This is because starting from it, there is no N-1 relation either directly or indirectly.
The extended table concept simplifies the way to access several tables when you are positioned in a specific Base Table.
Videos
Base and Extended table
"
38,What is a Formula,"https://wiki.genexus.com//commwiki/wiki?5861,Category%3AFormulas","Formulas are expressions that, once evaluated, return a certain value.
When an attribute or variable value can be calculated from other attributes, variables, constants, methods, arithmetic operations, etc., it can be defined as a Formula. In addition, when this assignment is done associated with an attribute definition (that is, for the attribute, inside the Transaction Structure where it is specified), the attribute itself is known as a Global Formula. 

There are two ways to define formulas:
Global Formulas (Global definition, at the Knowledge Base level)
Local / Inline Formulas (Local definition, within objects' code)
Classification of Formulas by navigation type
Formulas can be classified into three groups, depending on the type of calculation needed. This classification is valid either for global or local formulas.
Horizontal Formulas:  Allow defining many kinds of expressions (such as arithmetic, among others) involving a single record and its associated Extended Table.
Aggregate Formulas:  Allow defining some calculations or searches involving many records of a table (and its related data that belong to the Extended Table).
Compound Formulas: Several Horizontal and/or Aggregate expressions combined.
All these kinds of formulas may have trigger conditions.
Note:  When defining a formula, you don't need to indicate if it belongs to one classification or another. This is only an external classification.
Base table of a Formula
The table that is navigated in order to evaluate the formula is known as its base table. Depending on the kind of formula, the evaluation will consider only one record (horizontal formula) or many (aggregate formula).
Optimized generated code
Defining formulas is even better than writing Procedure objects and invoking them.
When you define a formula, GeneXus has the knowledge of its definition and is able to generate optimized sentences by combining the formula query with the query in which the formula is present.
On the other hand, if you define a Procedure and invoke it, the Procedure code is not ""visible"" from the invoker, and GeneXus can't combine the knowledge and generate the most optimized code.
See Also
Formulas/Generating SQL
Changes in Formulas terminology
Videos
Defining Attributes as Formulas
"
39,Global Formulas,"https://wiki.genexus.com//commwiki/wiki?6440,Global+Formulas","A Global Formula, also known as ""formula attribute"" is an attribute to which you can assign an associated calculation. Thus GeneXus has the knowledge to calculate the formula wherever the attribute is mentioned.
Only an attribute can be defined as a global formula (not a variable). Moreover, the only variables allowed inside the formula expression are those visible in all the KB, in every object, that is, system variables (such as &today).
Where do you define an attribute as a global formula? In the Transaction structure, when defining its name and data type. It is also possible to specify a formula with the Formula Editor. Look at the following image:

The calculation itself, that is also known as formula itself, can be any horizontal, aggregate, or compound expression.
Global formula attributes are ""virtual attributes"" because they are not physically stored in a table by default (but you can change this if you want to, defining the attribute as redundant). In spite of this, for each object that references a global formula, GeneXus includes in its corresponding generated program the necessary code to calculate and display the result at runtime.
As it was said, global formula attributes aren't stored in a table. However, each global formula attribute has an associated table: the table that would belong to if it were not defined as a formula. In the above example, the associated table of FlightInstancePrice will be FLIGHTINSTANCE.
It represents the context of the formula. In other words, whenever the formula attribute is written, another attribute of the same table could have been written instead. That is, if the code is well programmed, at the moment the formula calculation triggers, you are positioned in a certain register of that table.
Videos
What are formulas?
 Inline formulas


"
40,"Sum, Count, Average","https://wiki.genexus.com//commwiki/wiki?6500,Sum%2C+Count%2C+Average+formulas","Sum, Count and Average are Aggregate Formulas.
Syntax
{Sum | Count | Average}( <aggregateExpression>, <aggregateCondition>, <defaultValue> ) [if <triggeringCondition>]
Where:
<aggregateExpression>
Is the expression to be aggregated, that is to say, the expression to be summed up, or averaged. It may contain attributes (even formula attributes), constants and variables (variables only are allowed in inline formulas).

For Sum and Average, the <aggregateExpression> result data type must be numeric. For Count, the first parameter must be an attribute (not an expression) that belongs to the table in which you need to count records (*).
<aggregateCondition>
Is a combination of a search condition with a Data Selector invocation. Both parts are optional:
[<SearchCondition>] [USING <DataSelector> '(' <Parameter>1, <Parameter>2, <Parameter>n ')']
<SearchCondition>
Is the condition that records must verify to be considered in the aggregation. It may contain attributes, constants and variables (user variables are allowed only in inline formulas, GeneXus standard variables in global formulas and inline formulas).
<defaultValue>
Is the returned value when no records match the <aggregateCondition>. It is a constant and it is optional.
<triggeringCondition>
Is the condition that determines if the formula must be triggered or not. It is optional. The only attributes allowed are those belonging to the contextual table (that the formula attribute would belong to if it were stored) and its extended.
Note: Return value is rounded according to the definition of the attribute or variable which is assigned with the aggregate expression.
For instance, if you assign AttributeB=Average(AttributeA) having 3 records of AttributeA with values 1, 3 and 1,
if AttributeB is defined as N(10.5), will have value 1,66667
if AttributeB is defined as N(7.2), will have value 1,67
(*) All records are count, even those where the mentioned attribute is null.
Samples
Consider the following Transactions:
Flight
{
   FlightId*
   FlightDescription
   FlightPrice
   FlightInstanceAveragePrice = Average(FlightInstancePrice, FlightInstanceDate = Today(), 0);
   FlightInstanceTotalPrice = Sum(FlightInstancePrice);
   FlightInstanceCountDate = Count(FlightInstanceNumber) if FlightPrice > 100;
}

FlightInstance
{
   FlightInstanceNumber*
   FlightId
   FlightDescription
   FlightPrice
   FlightInstanceDate
   FlightInstanceNumberOfPassengers
   FlightInstancePrice = FlightPrice if FlightInstanceNumberOfPassengers <= 100;
        FlightPrice * 0.9  if  FlightInstanceNumberOfPassengers > 100 and FlightInstanceNumberOfPassengers < 200;
        FlightPrice * 0.8  otherwise;
FlightInstanceNumberOfPassengers = Count(PassengerName,PassengerName = ""Smith"",0);
   {
       PassengerId*
       PassengerName
   }
}
The above example shows several Aggregate global formulas with their associated definitions (note that all the defined formulas are Aggregate formulas except for the FlightInstancePrice formula).


"
41,"Max, Min","https://wiki.genexus.com//commwiki/wiki?6502,Max%2C+Min+Formulas","Max and Min are Aggregate Formulas.
Syntax
{Max | Min}( <expressionToBeMaxOrMin>, <aggregateCondition>, <defaultValue> , <returnedAttributeValue> )  [ if <triggeringCondition> ]
where:
<expressionToBeMaxOrMin>
Is the expression whose resultant value will be maximized/minimized, among the records fulfilling the <aggregateCondition>. It may contain attributes (even formula attributes), constants and variables (variables are allowed only in inline formulas)
<aggregateCondition>
Is a combination of a search condition with a Data Selector invocation. Both parts are optional:
[<SearchCondition>] [USING <DataSelector> '(' <Parameter>1, <Parameter>2, <Parameter>n ')']
<SearchCondition>
Is the condition that records must verify to be considered in the aggregation. It may contain attributes, constants and variables (user variables are allowed only in inline formulas, GeneXus standard variables in global formulas and inline formulas).
<defaultValue>
Is the returned value when no records match the <aggregateCondition>. It is a constant and it is optional.
<returnedAttributeValue>
Attribute whose value is returned by the formula when it finds records that fulfill the <aggregateCondition> and after maximizing/minimizing the <expressionToBeMaxOrMin>.
<triggeringCondition>
Is the condition that determines if the formula must be triggered or not. It is optional. The only attributes allowed are those belonging to the contextual table (that the formula attribute would belong to if it were stored) and its extended.
Example
Having the following two transactions: Flight to store the general information about flights (like its description and prices by date), and FlightInstance to store the actual information of a certain flight:
Flight {
       FlightId*
       FlightDescription
       Prices
          { FlightDate*
            FlightPrice }}

FlightInstance {
       FlightInstanceNumber*
       FlightId
       FlightDescription
       FlightInstanceDate
       FlightInstancePrice = max(FlightDate, FlightDate <= FlightInstanceDate, 0, FlightPrice)}
Look at the following image, which shows the FlightInstancePrice attribute being defined as a Max global formula using the GeneXus formula editor:

The base table of the formula, that is, the navigated table in order to make the calculation is: FLIGHTPRICES.
The formula has a context: the FLIGHTINSTANCE table, this means when the formula is triggered, we are positioned on that table. More precisely: on one of its records, with a certain FlightInstanceNumber value. Thus, at the moment the formula is going to be evaluated, it already knows all the FLIGHTINSTANCE table (and its extended) attributes for this record. Among them, FlightId and FlightInstanceDate.
Therefore, not all the records that fulfill the explicit aggregate condition ""FlightDate <= FlightInstanceDate"" will be considered for the maximization, but only those that correspond to the flight, that is, the FlighId of the FLIGHTINSTANCE record.
Thus, all records considered will verify, also: FLIGHTPRICES.FlightId = FLIGHTINSTANCE.FlightId
In sum, the max formula will navigate the FLIGHTPRICES table filtering the records that verify the <aggregateCondition> (FlightDate <= FlightInstanceDate) and also applying the automatic filter inferred by GeneXus (FLIGHTINSTANCE.FlightId = FLIGHTPRICES.FlightId); then, for the selected records that fulfill both mentioned filters, the <expressionToBeMaxOrMin> will be maximized (this means that the record which has the FlightDate maximum value will be chosen) and the <returnedAttributeValue> associated to that record will be returned as the formula result (FlightPrice). If none record fulfill both filters, then 0 (the <defaultValue>) will be returned.





"
42,Find,"https://wiki.genexus.com//commwiki/wiki?6547,Find+Formula","Find is an Aggregate Formula.
Syntax
Find ( <aggregateExpression>, <aggregateCondition>, <defaultValue>) [ if <triggeringCondition> ];
Where:
<aggregateExpression>:
Is the expression whose resultant value will be returned according to the first record found that matches the <aggregateCondition>. It may contain attributes (even formula attributes), constants and variables (user variables are allowed only in inline formulas).
<aggregateCondition>:
Is a combination of a search condition with a Data Selector invocation. Both parts are optional:
[<SearchCondition>] [USING <DataSelector> '(' <Parameter>1, <Parameter>2, <Parameter>n ')']
<SearchCondition>
Is the condition that records must verify to be considered in the aggregation. It may contain attributes, constants and variables (user variables are allowed only in inline formulas, GeneXus standard variables in global formulas and inline formulas).
<defaultValue>
Is the returned value when no records match the <aggregateCondition>. It is optional and only constant values are accepted (if the formula is being used with Date attributes, see this article too).
<triggeringCondition>
Is the condition that determines if the formula must be triggered or not. It is optional. The only attributes allowed are those belonging to the contextual table (that the formula attribute would belong to if it were stored) and its extended.
Example
Flight
{
    FlightId*
    FlightDescription
    Price
    {
        FlightDate*
        FlightPrice
    }
}

FlightInstance
{
    FlightInstanceNumber*
    FlightId
    FlightDescription
    FlightInstanceDate
    FlightInstancePrice
    FlightInstanceCurrencyValue = Find(CurrencyValue, CurrencyId = ""Dollar"" and CurrencyDate = FlightInstanceDate, 0) if FlightId=1;
}

Currency
{
    CurrencyId*
    Value
    {
         CurrencyDate*
         CurrencyValue
    }
}
The above example shows a defined Find global formula.
The following image shows the FlightInstance transaction being edited (using the GeneXus transaction editor) and the FlightInstanceCurrencyValue global formula attribute being edited (using the GeneXus formula editor):

FLIGHTINSTANCE is the contextual table of the FlightInstanceCurrencyValue global formula attribute.
CURRENCYVALUE is the table navigated by the Find formula in order to make the calculation.
The find calculation only triggers for the FlightId = 1.
The tables involved in the formula definition don't store common attributes, so GeneXus will not automatically apply any additional filter (only the defined <aggregateCondition> will be considered to find the searched record). Thus, the first record found in the CURRENCYVALUE table that fulfills the <aggregateCondition> will be selected, and the corresponding defined expression will be returned (in this example: a CurrencyValue is returned by the formula).
Note that in this example the defined <aggregateCondition> contains a filter by the primary key of the navigated table, so the navigated table may have a unique record that fulfills the <aggregateCondition>. This is the most common use of Find formulas, meaning that we usually define Find formulas to search for a certain value, filtering by the primary key of the navigated table (so that a unique record will fulfill the <aggregateCondition>). When filtering by secondary attributes or foreign key attributes, since many records may fulfill the <aggregateCondition>, the first record found that fulfills the <aggregateCondition> will be selected.









"
43,Arithmetic expressions,"https://wiki.genexus.com//commwiki/wiki?5864,Horizontal+Formulas","Horizontal Formulas allow defining expressions (either arithmetic or any other kind).
What determines a formula is horizontal (as opposite to aggregate) is the fact that attributes involved belong to one extended table.

For example: ""FlightInstancePrice = FlightPrice * 0.9"" being FlightInstancePrice an attribute virtually in FLIGHTINSTANCE table (table A in diagram) and FlightPrice in FLIGHT table (table B in diagram) where for each flight instance there is one and only one associated Flight (that is: FLIGHT belongs to the FLIGHTINSTANCE extended table).
Horizontal formulas can be either global (assigned to attributes at transaction structure level, indicating those attributes always assume the result of a calculation) or local (or inline, assigned to attributes, variables, elements of Data Providers, SDTs, etc., or being part of conditions that are evaluated in runtime). That is:
Horizontal Global Formula: <attribute> = <horizontalConditionalFormula>
Horizontal Inline Formula: {{<variable>|<attribute>} = <horizontalUnconditionalFormula>} | <horizontalUnconditionalFormula>
The main difference between global and inline, is while an inline horizontal formula is simply an expression, global horizontal formula may consist of several conditional expressions. In addition, as in any inline formula, variables could be involved in the expression (because the formula does only exists in this local piece of code, where the variable is known. Whereas you really don't know all the places where a global formula is going to be triggered. This is the meaning of ""global"". It can be used everywhere an attribute of the corresponding base table is allowed)
Saying ""horizontal inline formula"" is the same as saying: expression. Wherever you can write an expression, you are particularly writing an horizontal formula. That's why the concept of ""inline horizontal formula"" is not very productive. Not so for ""global horizontal formula"", that let's say that an attribute will always be calculated in this way.
Meanwhile, an Aggregate formula does not need a context to be evaluated, a horizontal does. It will be understood below by means of two examples.
Syntax
<horizontalConditionalFormula>::= <exp>1 [ if <cond>1 ] [ ;<exp>2 [ if <cond>2 ]] [ ;<exp>n [otherwise | if <cond>n ]]
<horizontalUnconditionalFormula>::= <exp>
Where:
<exp>n  may be any valid expression. It can include the following:
Attributes (from the formula navigation table and its extended table. They could also be formula attributes themselves)
Variables (only system variables for global, and both kind -system and user- for inline formulas, as long as they are already defined on the object)
Constants
Functions, methods and properties
Arithmetical operators (+, -, *, /, ^)
String operators (+)
Date operators (+, -)
Comparative operators (<,<=, =, >, >=, >, like) when the expression is of boolean data type
Logical operators (and, or, not) when the expression is of boolean data type
<cond>n  may be any valid triggering condition. It can include the following:
Attributes (from the formula navigation table and its extended table)
Constants
Functions, methods and properties
Logical operators (and, or, not)
Comparative operators (>, <, =, >=, <=, like)
The result returned by a horizontal formula will be the expression related to the first condition returning True. The others will not be evaluated.
<otherwise>: when none of the evaluated triggering conditions return True, if there is an Otherwise clause in the formula definition, the returned result will be the expression associated with this clause.
Consideration when used in Smart Devices
The client-side Events grammar in Smart Devices is limited regarding the events executed on the server. That's why allowed inline expressions not only are horizontal (aggregate are not allowed), but also are a reduced set of what you have seen above.

Example: global formula
Flight
{
   FlightId*
   FlightDescription
   FlightPrice
}

FlightInstance
{
  FlightInstanceNumber*
  FlightId
  FlightDescription
  FlightPrice
  FlightInstanceNumberOfPassengers
  FlightInstancePrice = FlightPrice if FlightInstanceNumberOfPassengers <= 100;
                        FlightPrice * 0.9 if FlightInstanceNumberOfPassengers > 100 and FlightInstanceNumberOfPassengers < 200;
                        FlightPrice * 0.8 otherwise;
  FlightInstanceTotal = FlightInstanceNumberOfPassengers * FlightInstancePrice;
}
The FlightInstancePrice and FlightInstanceTotal attributes are both horizontal formulas (in the above example the associated calculations are shown). They are all global formulas.
Look at FlightInstancePrice definition. Its associated table is FLIGHTINSTANCE (the table the attribute would be if it were physically stored). The formula attributes belong to the FLIGHTINSTANCE extended table (that is to say, FLIGHTINSTANCE and FLIGHT tables). Note it is defined as three conditional expressions. In the example below, the same definition but inline will be explained.
FlightInstanceTotal also has FLIGHTINSTANCE as its base table (involve attributes that belong to the FLIGHTINSTANCE extended table), but the definition is unconditional.
In both cases, the formulas have a context: the FlightInstance first level transaction. They are not defined in isolation.
The following image shows the ""FlightInstance"" transaction being edited with the GeneXus transaction editor, and the FlightInstancePrice horizontal formula attribute being edited with the GeneXus formula editor:

Example: local/inline formula
If you did not have the flight instance price calculated as a formula attribute, and you need it inside a procedure code, you would write:
Do case
    case FlightInstanceNumberOfPassengers <= 100
       &price = FlightPrice
   case FlightInstanceNumberOfPassengers > 100 and FlightInstanceNumberOfPassengers < 200
      &price = FlightPrice*0.9
   otherwise
       &price = FlightPrice*0.8
endcase
Strictly speaking, here you have three expressions, that is, three inline formulas. Observe this code only makes sense in a context where you are positioned in the FlightInstance table. Thus, this code block must be within that appropriate context.
You would still have an inline formula when assigning it to an attribute outside the attribute definition level. That is: if you have in a procedure source:
For each order FlightInstanceNumber
   Do case
       case FlightInstanceNumberOfPassengers <= 100
          FlightInstancePrice = FlightPrice
       case FlightInstanceNumberOfPassengers > 100 and FlightInstanceNumberOfPassengers < 200
         FlightInstancePrice = FlightPrice*0.9
       otherwise
         FlightInstancePrice = FlightPrice*0.8
   endcase
endfor
Here you are locally assigning the result of the formula evaluation to the attribute FlightInstancePrice, which is not itself a formula, but a normal attribute (like any other). Only here, inside this code, it is calculated in such a way.
Contextual table
You have seen that for the formula to be meaningful, it must be in a context where you are positioned on a table that reaches all the formula attributes by means of its extended. That is why the presence of the same formula will affect this contextual table determination as well.
For example, having a for each as context:
for each order FlighPrice
   &total = &total + FlightInstanceNumberOfPassengers * FlightInstancePrice
endfor
The for each base table is not FLIGHT but FLIGHTINSTANCE, because of the attributes of the expression (formula).









"
44,Compound Formulas,"https://wiki.genexus.com//commwiki/wiki?5879,Compound+Formulas","A Compound Formula is an expression whose definition includes several Horizontal and/or Aggregate formulas.
Look at the following example. Given these transactions:
Flight Transaction
FlightId*
FlightDescription
FlightPrice
FlightInstanceAveragePrice = Sum(FlightInstancePrice) / Count(FlightInstanceDate)
FlightInstance Transaction
FlightInstanceNumber*
FlightId
FlightDescription
FlightPrice
FlightInstanceDate
FlightInstanceNumberOfPassengers
FlightInstancePrice = FlightPrice if FlightInstanceNumberOfPassengers <= 100;
FlightPrice * 0.9 if FlightInstanceNumberOfPassengers > 100 and FlightInstanceNumberOfPassengers < 200;
FlightPrice * 0.8 otherwise;
FlightInstanceAveragePrice is a Compound Formula (defined in a global way).
The following image shows the ""Flight"" transaction being edited with the GeneXus transaction editor, and the FlightInstanceAveragePrice compound formula attribute being edited with the GeneXus formula editor:

Note that FlightInstancePrice is an horizontal formula.



"
45,Local/Inline Formulas,"https://wiki.genexus.com//commwiki/wiki?6441,Inline+Formulas","An Inline Formula is a local formula defined within an object code (for example in the middle of a Procedure Source, in an object subroutine, in a Data Provider statement, etc.).
In other words, a formula can be locally assigned to an attribute or variable, as a sentence or statement in the middle of the code, or in a where clause, etc.
Syntax
<variable>|<attribute> = <UnconditionalFormula>} | <UnconditionalFormula>
An inline formula (<UnconditionalFormula>), can be either horizontal or aggregate.
The main difference regarding Global Formulas is that inline may not consist of several conditional expressions, not even a single conditional one. In addition, in any inline formula, variables could be involved in the expression (because the formula does only exists in this local piece of code where the variable is known).
Whereas you really don't know all the places where a global formula is going to be triggered. This is the meaning of ""global"". It can be used everywhere an attribute of the corresponding base table is allowed)
While Global Formulas always have a table in its context (the table where the formula attribute would be stored if it were not virtual), inline formulas do not have to. For what kind of formulas? Those that don't need context to be evaluated: Aggregate Formulas.
Why the context is meaningful?
Because it will affect the calculation result, allowing to add filtering conditions to the data considered.
Example
Assume you have a FlightInstance Transaction object to store a real flight from one country/city to another, with a second level, FlighInstanceSeat, to store the passengers of the flight. Suppose a Procedure object needs to know at the beginning if there already are more than 100 seats assigned to passengers in the corresponding table.
&success = Count(FlightInstancePassengerSeatNumber) > 100
Here there is no context table for the formula. It is triggered isolated, counting all the records of its base table, FlightInstanceSeat. It will count all the passengers for all the flight instances stored.
On the other hand, if the above code were inside a for each command, such as:
for each FlightInstance
   where Count( FlightInstancePassengerSeatNumber) > 100
      print flightInstanceInfo //FlightInstanceNumber, FlightInstanceDate
   endfor
The formula does have a context: the FlightInstance table, the base table of the For each. Thus, not all the passenger seats were going to be counted, but only those corresponding to each FlightInstance record considered in each ""for each"" iteration. So, only the flights with more than one hundred passengers will be printed in the output.
If you had defined a global formula attribute FlightInstanceNumberOfPassengers at FlightInstance transaction level, you could have defined equivalently as follows:
for each FlightInstance
   where FlightInstanceNumberOfPassengers > 100
      print flightInstanceInfo //FlightInstanceNumber, FlightInstanceDate
   endfor
Furthermore, if there is a contextual table, all the attributes of its extended table could be used inside the formula, as known. For example, having a variable &fromDate previously loaded:
for each FlightInstance
   where Count( FlightInstancePassengerSeatNumber, FlightDate >= &fromDate) > 100
      ...
   endfor
Note
Inline formulas that are horizontal always have a context table: at least its own base table. It is exactly the same as horizontal global formulas. Thus, they can not be specified without a context where the attributes could assume value.
For example:
&age = &today.Year() - PassengerBirthDate.Year()
this assignment isolated makes no sense. What passenger birth date are you talking about? The situation would be different if this assignment were:
for each FlightInstanceSeat
    &age = &today.Year() - PassengerBirthDate.Year()
   ...
endfor
Here GeneXus infers the passenger is that of each ""for each"" iteration, that is, that associated with the for each base table record where you are positioned each time. The ""for each"" navigates the table that stores the passengers assigned to seats: FlightInstanceSeat. Note in this case the context table, FlightInstanceSeat, is not exactly the base table of the formula, Passenger, but the former contains in its extended the latter.
So, inline formulas can be defined according to their context:
Within a contextual table
Outside a contextual table
Videos
Inline Formulas
"
46,Within a contextual table,"https://wiki.genexus.com//commwiki/wiki?6426,Inline+Formulas+within+a+contextual+table","As it was mentioned before when introducing  Inline Formulas, the fact a formula has a table in its context at evaluation time will affect its result. And its very definition, either.
Whether horizontal, the context is required in order to determine which record of its base table is ""the one"". Also the formula itself will affect this contextual table determination. Thus, you have a mutual influence.
Whether aggregate, however, the context is not necessary, but if there exists, will cause not all the records the formula explicitly states are considered, but only those also matching implicit conditions arising from that context. When this happens, you are allowed to include attributes of that contextual table (and its extended) into the formula definition as known values (from context, indeed). Contrary to what happens with horizontal formulas, aggregation ones are not involved in determining the context base table at all. In other words, its attributes are only involved in determining the formula base table itself.
What scenarios state contextual table?
For Each command
Data provider Group with base table
A grid control with base table (and its related events; e.g.: Load)
Form fixed part of a panel in Smart Devices with base table (and its related events; e.g.: Refresh)
Conditions (general conditions as well as related to grids or those of where clauses) 
Transaction rules

Examples
Given the following transaction:
FlightInstance      //transaction name = first level name
{
FlightInstanceId* 
FlightInstanceDate
FlightInstanceNumberOfPassengers
FlightNumber 
FlightDescription 
    Seat                   //level name    
          { PassengerId* 
            PassengerName 
            FlightInstancePassengerSeatNumber } 

}
Look at the following examples of inline formulas programmed inside a context with base table:
Example 1
For each
     FlightInstanceNumberOfPassengers = Count(FlightInstancePassengerSeatNumber)
EndFor
First of all, note that you are assigning a formula to an attribute. As it is an inline formula (local calculation), the attribute physically exists in a table. So, the result of the calculation is assigned to the attribute, to be stored in the corresponding record with which you are working (so, the code must be inside a Procedure object source). Only when defining a Global Formulas the attribute is a ""virtual"" definition.
In this example, the table navigated by the formula is FLIGHTINSTANCESEAT because the unique attribute involved in the formula definition is: FlightInstancePassengerSeatNumber, which is stored in that table. And the For Each base table is FLIGHTINSTANCE (this is determined by the unique attribute which is present inside the For Each and outside of the formula: FlightInstanceNumberOfPassengers).
Note: as of GeneXus X Evolution 3 you would probably have specified the BaseTrn in the for each (i.e. for each FlightInstance...)
Thus, the For Each command is navigating all the flight instances, and for each one, the Count formula is navigating its passengers and counting them. As there is a common attribute in both navigated tables (FLIGHTINSTANCE and FLIGHTINSTANCESEAT), which is FlightInstanceId, the formula automatically counts for each flight instance, its assigned passengers (in other words, the filter FLIGHTINSTANCESEAT.FlightInstanceId = FLIGHTINSTANCE.FlightInstanceId is included automatically in the generated code associated to the formula).
Example 2
Note the same is valid for formulas assigned to any Data Provider Element inside a Data Provider Group statement with base table, due to the equivalence between for each command and group of a Data Provider.
Having a Data Provider that returns a collection SDT as output, ActualFlights:
ActualFlights 
{
   FlightInstance 
   {
       Date = FlightInstanceDate
       NumberOfPassengers = Count( FlightInstancePassengerSeatNumber)
   }
}
Note that you are doing the same than the previous example: the group ActualFlights is navigating all the flight instances (its base table is FLIGHTINSTANCE by means of the attribute FlightInstanceDate at the right of the ""=""), and for each one, the Count formula is navigating its passengers and counting them (the table navigated by the formula is FLIGHTINSTANCESEAT).
Remember that the FlightInstancePassengerSeatNumber attribute participates in the formula definition, but not in the group definition.
Example 3
An analogous context than before you would have if you had a grid in a web panel (with base table: FLIGHTINSTANCE):

with the following Event code:
Event Load
   FlightInstanceNumberOfPassengers = Count( FlightInstancePassengerSeatNumber)
endevent
Due to the grid base table, the Load will be executed once for each FlightInstance record being loaded into the grid.
Example 4
Having a Panel for Smart Devices that receives as parameter FlightInstanceId and then shows its information:

In order to assign the variable &NumberOfPassengers the corresponding value, and remembering the Refresh event executes when the form fixed part is being loaded:
Event Refresh
   &NumberOfPassengers = Count( FlightInstancePassengerSeatNumber )
endevent
Example 5
For each order FlightInstanceDate
     where Count(FlightInstancePassengerSeatNumber) > 50
         ....
Endfor
Here you have an example in which an inline formula is defined in the Where clause.
The For Each base table is FLIGHTINSTANCE (this is determined by the unique attribute which is present in the For Each command and outside of the formula: FlightInstanceDate); and the table navigated by the formula is FLIGHTINSTANCESEAT because the unique attribute involved in the formula definition is: FlightInstancePassengerSeatNumber.
Note that there is an implicit filter determined by GeneXus for the formula, which is: FLIGHTINSTANCE.FlightInstanceId = FLIGHTINSTANCESEAT.FlightInstanceId (as FlightInstanceId is a common attribute between the For Each base table and the navigated table by the formula, the formula automatically counts the assigned passengers for the flight instance which is being navigated).
Summing up, the For Each command is navigating all the flight instances that have more than 50 passengers.









"
47,Outside a contextual table,"https://wiki.genexus.com//commwiki/wiki?6442,Inline+Formulas+outside+a+contextual+table","As it was mentioned before when the Inline Formulas were introduced, the fact a formula has a table in its context at evaluation time will affect its result. And its very definition, either.
When an inline formula is defined without a contextual table, at the moment the formula is triggered you are not positioned on any table. Consequently, this is only valid for Aggregate Formulas, and in the formula definition you can only include attributes that belong to the desired table to be navigated and its extended table, in addition to variables.
What scenarios do not state contextual table?
Procedure Source: outside For Each command (or inside whether When None Clause block code).
Procedure Source: attribute assignment inside New command (only whether outside When duplicate clause).
Events with no associated base table: outside for each commands.
Subroutines: outside for each commands.
Data provider Group with no base table (at Data Provider Element statement)
SDT or Business Component (element assignment): outside every block code with base table.

Given the following transactions:
Customer             //transaction name
  {CustomerId*
  CustomerName}

Invoice             //transaction name
  {InvoiceId*
  InvoiceDate
  CustomerId
  CustomerName
  InvoiceTotal}
In the following examples, note how the same formula has a contextual table and implicit filters when it is defined inside a For Each command; and when it is defined outside a For Each command, it has neither a contextual table nor implicit filters:

In the first example, the For Each base table is: CUSTOMER and as the Sum formula is defined inside the For Each, its contextual table is also CUSTOMER. Even though the Sum formula only involves an attribute that belongs to the INVOICE table (which is the desired table to be navigated by the formula), it could also contain attributes that belong to the CUSTOMER table and its extended table, in addition to variables.
Another thing to consider in the first example is that GeneXus determines an implicit filter for the formula, which is: INVOICE.CustomerId =  CUSTOMER.CustomerId (because CustomerId is a common attribute between the For Each base table and the table navigated by the formula). So, for each customer navigated by the For Each, its invoices are summarized.
Note: as of GeneXus X Evolution 3 you would probably have specified the BaseTrn in the for each (i.e. for each Customer...)
In the second example, the same Sum formula was defined, but outside a For Each command. Thus, the formula doesn't have a contextual table, and it can only involve attributes that belong to the desired table to be navigated by the formula and its extended table, in addition to variables. Besides this, the formula won't have implicit filters inferred by GeneXus. So, in this example all the invoices are summarized.
Important consideration
The formula is triggered when the group that contains the formula begins.
This means that if you have a formula defined in a certain line of the code with its parameters, the parameter values will be those that were read at the moment that the group was executed in the data base. So, if the group was executed in the database, and after that, you have assigned different values to the parameters that you will involve in the formula definition, the parameter values taken into account won't be those that you have assigned; on the contrary, they will be those read when the group that contains the formula was executed in the database.
So, when are groups executed?
when a program begins
when a For Each begins
after an Endfor
when a subroutine or event begins
The same happens with variables. The variable values which are taken into account when the formulas are triggered, are the values that the variables have assigned at the moment that the group that contains the formula is executed. So, if you write the following code:
&CustomerId = 1
&total = Sum(InvoiceTotal, CustomerId = &CustomerId)
The &CustomerId variable won't have a value at the moment that the formula is triggered.
This can be solved as follows:
&CustomerId = 1
Do 'CalcTotal'
...

Sub 'CalcTotal'
    &total = Sum(InvoiceTotal, CustomerId = &CustomerId)
EndSub
In this way, as there is a new beginning of a group (when the subroutine begins) and the formula is included inside the subroutine, when the formula is executed the &CustomerId variable already has the desired value.
Note
Whenever you want an isolated evaluation you can also use a procedure to do the calculation.









"
48,Variable definition,"https://wiki.genexus.com//commwiki/wiki?7375,Variable+definition","You may define variables in most GeneXus objects.
GeneXus objects that allow defining variables, contains a selector named Variables in order to define and manage them.

If you select it, the Variables Editor will be opened.
Variables are local, which means that they are accessible only inside the object. If you need to send some variable values to another object, you can call the desired object, sending the variables as parameters to it.
After defining a variable, you will be able to use it (inside an allowed section like the Source, Rules, Events, etc.) referencing its name preceded by the & symbol.
For example, if you define a variable named &Quantity, then being in a section of the same object where it is allowed to use variables, you can type & and you will be able to select the &Quantity variable or other defined variable.
Each variable has some properties in order to set them. The main properties are the following:
Properties


Name


Description


Based on


Data type
Depending on the Data Type property you choose, different related properties are offered to set them.
See also
Picture editor
Using arrays
Built-in variable list








"
49,Variables Editor,"https://wiki.genexus.com//commwiki/wiki?3173,Variables+Editor","When you click on the Variables selector of a certain object, you enter to the Variable Editor which allows you to create, update and delete variables in your object.

Look at the Properties Editor on the right. There you can set the different properties related to the variable in which you are positioned.
You have other ways to define variables. For example, from the Insert Variable dialog.
See Also
Collection variables


"
50,Automatic variable definition,"https://wiki.genexus.com//commwiki/wiki?12557,Automatic+variable+definition","When you write variables directly in the code, and GeneXus automatically defines it if possible. The criteria used to determine the type are:
Based on: If you have for example a ""Name"" Domain (or Attribute) and you mention &CountryName in the source, the variable CountryName is defined based on the Domain (Attribute) ""Name"".  If the attribute ""CountryName"" exists, it will be based on it instead.


Boolean: If the variable has the prefix ""&is"",""&Is"",""&has"" or ""&Has"", followed by a string starting with a capital letter, it will be defined as Boolean.


Collection: If the variable has this format: ""&xx[<Attribute Name>|<Domain Name>|<SDT Name>]Collection"", being ""xx"" a free text, it will be defined as a collection based on the attribute|domain|sdt (provided there isn't an attribute, domain, or SDT with that full name). For instance, suppose you have an SDT named ""Customer"". If you write &MyCustomerCollection, the variable is defined as a collection of the Customer data type.


Boolean Collection: 3 components are required to automatically define a variable as a Boolean Collection: ""&is"" + <free text starting with capital letter> +""Collection"". For instance: &isAvailableCollection.
Specification and Variables not defined
Undefined variables, which have not been manually defined nor automatically defined using the criteria explained before, are assigned with a type at specification time using the following criteria:
If the variable is assigned with an attribute, the type and length of the attribute will be used to define the variable.
	i.e. &ClientName = ClientName, the type and length of the ClientName attribute is assumed for the variable. If there more than one for the variable, only the first one is taken into to assume the type.
If a function is assigned to the variable, the returned type of the function is assumed for the variable. In this case the length cannot be automatically assumed, so Numeric variables will have length = 10,2 and Character variables will have length = 40.
	i.e. &Variable1 = val(Attribute), Variable1 will be N(10.2).
	&Variable2 = Attribute.ToString(), Variable2 will be C(40).
Otherwise, Numeric type and length = 10,2 is assumed for undefined variables.
In all cases, when a type is assumed for a variable at specification time, a warning is displayed in the navigation report: warning: spc0047: Variable Variable2 not defined; N(10.2) assumed.

"
51,Collection variables,"https://wiki.genexus.com//commwiki/wiki?6352,Collection+variables","When defining a variable, in any context, once the data type is established, you have the choice to declare it as a collection - not as a simple variable of that data type:



The default Collection property (IsCollection checkbox) value is 'False'. If you set it to 'True', you'll have a collection variable whose items are of the established data type.
To work with the individual items of the collection, you have to define a simple variable of the collection items data type, to run through the collection, using the 'For IN' command.
For &var IN &collectionVar
   ...
EndFor
What data type can items have?
Any. Particularly, in addition to the basic (numeric, character, etc.) and extended ones (HttpRequest), it can be an SDT type (simple as well as collection), or a BC one.
It's worth mentioning that once it has been established that the variable is a collection, the Dimensions property automatically takes the 'Scalar' value. In other words, variables that are collections of arrays or matrices cannot be defined.
You can see the particular case of  Implementing SDT collections.
Considerations
Collection variables associated with basic GeneXus data types (such as Numeric, Character, Date and so on) are not supported on the form; for those cases, you need to define a Structured Data Type (SDT) object.
See also
Collection Domains
SDT on Form



"
52,For in command,"https://wiki.genexus.com//commwiki/wiki?6359,For+in+command","Traverses an array or a collection.
Syntax
For &Var in expression
   code
Endfor
Where:
&Var
   Specifies a variable that must have the same data type as the items of the expression
expression
   Any expression whose value is a collection, array or matrix.
code
   GeneXus code to be run in each iteration.

Samples
Suppose the expression is an array variable:
for &var in &varArray()
   … // code
endfor
The previous code stores each value of the array &varArray in the &var variable. For vectors of one dimension, the code is expanded to:
&x = 1
Do while &x <= rows(&varArray())
   &var = &varArray(&x)
   ... // code
   &x += 1
EndDo
Expression can also be an array of two dimension (matrix) variables:
for &var in &varMatrix()
   ... // code
endfor
The expanded code would be as follows:
&x = 1
Do while &x <= rows(&varMatrix())
   &y = 1
    Do while &y <= cols(&varMatrix())
       &var = &varMatrix( &x, &y)
       ... // code
       &y += 1
    EndDo
  &x += 1
EndDo
It may even be a collection variable of any type (including a variable with Collection Property set as 'False' but of an 'SDT collection' data type). For more details, see the two ways of Implementing SDT collections:
for &var in &collection
    ...
endfor
An expression can not only be a variable, but also, for example, the result of a Data Provider or a Procedure:
for &var in DataProvider(parms)
    ...
endfor
for &var in Procedure(parms)
    ...
endfor
Remember not to write any method, 'Udp method' is assumed.
In sum, any expression whose evaluation results in a collection, array or matrix, is a valid one to run through.
Notes:
The array/matrix/collection values cannot be changed during the scanning. This means that changes in the &Var value, in the command scope, do not affect the corresponding array/matrix/collection or vice versa.
The vector/matrix/collection position cannot be obtained during the scanning. For this, a variable must be defined as counter.
These structures can be nested to scan several arrays, matrixes or collections. This takes into account when a Subroutine that also has a For In is called within the structure.
Like in a For Each command or Do While, commands can be included that ""break"" the scanning, such as Exit or Return.
Available for User Events in
	
Android and
	
Apple since GeneXus 16 upgrade 3. In this case, Procedures and Data Providers cannot be used as part of the expression within the For in command. That is to say, when you are using the For in command in User Events on these platforms, you cannot use the output of a Procedure or a Data Provider as an expression.
See Also
Collection variables
Collection Domains






<!<a href='CDATA[td {
	border: 1.0px solid rgb(204,204,204);
}
br {
}
'>CDATA[td {
	border: 1.0px solid rgb(204,204,204);
}
br {
}
</a>]>
<!<a href='CDATA[td {
	border: 1.0px solid rgb(204,204,204);
}
br {
}
'>CDATA[td {
	border: 1.0px solid rgb(204,204,204);
}
br {
}
</a>]>
<!<a href='CDATA[td {
	border: 1.0px solid rgb(204,204,204);
}
br {
}
'>CDATA[td {
	border: 1.0px solid rgb(204,204,204);
}
br {
}
</a>]>
<!<a href='CDATA[td {
	border: 1.0px solid rgb(204,204,204);
}
br {
}
'>CDATA[td {
	border: 1.0px solid rgb(204,204,204);
}
br {
}
</a>]>
"
53,Diagram object,"https://wiki.genexus.com//commwiki/wiki?23941,Category%3ADiagram+object","Creates a diagram to include Tables, Transactions, Modules inside it and automatically see their relationships.
In the New object dialog, you can find it under the 'Documentation' category.
When a new Diagram object is created, it will be empty initially. Next, just drop a few Tables, Transactions, or Modules from the KB Explorer into the Diagram, and relationships will be shown automatically.

You can move the objects inside the Diagram as you wish, or you can right-click inside the Diagram and select Arrange Nodes.

Adding objects to a Diagram can be done in any of the following ways:
Drag and drop from KB Explorer
	 
When you have already included Tables or Transactions in a Diagram, you can right-click inside the Diagram and select:
	
Add superordinated
Add subordinated
Add [all] related
		 


When you have already included Modules, you can right-click inside the Diagram and select:
	
Add SubModules opSubmodulestion: Adds all the direct Submodules.
Add All SubModules: Adds all the direct submodules but the process is recursive, so, all the modules that are submodules to the one selected are also added to the Diagram.
Add References: Adds all the direct Referenced Modules.
Add All References: Adds all the Referenced Modules and recursively the Modules referenced by them.
Diagrams are dynamic
Every time the Diagram object is opened, it shows the current relationship between the Tables or Transactions that belong to that Diagram. That is to say, if the referential integrity between two tables changes when the Diagram containing those tables is reopened, it will show the new relationship (adding or removing arrows).
Diagrams can also be saved as images or copied to the clipboard for further use.
See Also
Table Diagrams 
Transactions Diagrams

"
54,Subtype Group object,"https://wiki.genexus.com//commwiki/wiki?20206,Category%3ASubtype+Group+object","Defines a group of attributes as an alias of others.
Description
An attribute can be a 'subtype' of another, meaning that the first attribute is just the second attribute with another name.
Subtypes must be defined in 'Groups'. For example, given the Airport Transaction object:
Airport
{
    AirportId*
    AirportName
}
The subtypes of AirportId and AirportName must be defined in a group as follows:
DepartureAirport Subtype Group


DepartureAirportId is a subtype of AirportId


DepartureAirportName is a subtype of AirportName
A Group can be viewed as a 'virtual' transaction in the sense that even if the Subtype Group definition doesn't indicate GeneXus by itself that a table must be created to store departure airports, it has all the other properties of a Transaction (a Group key, a Base Table, etc.).
DepartureAirportId is a subtype attribute and AirportId is its supertype attribute. In the same way, the DepartureAirportName attribute is a subtype and AirportName is its supertype. A well-defined Subtype Group must contain a subtype attribute or a set of subtype attributes, whose corresponding supertype attributes make up the primary key of an existing physical table. In the above example, there is a physical table whose primary key is AirportId: the AIRPORT table (and that physical table is the Base Table of the Group).
The Subtype Group definition allows:
Subtypes of supertypes that belong to the base table of the Group.
Subtypes of supertypes that belong to the Extended Table of the base table of the Group.
Formula attributes can be used in the group definition, with the exception of formulas that use UDP calls.
Note
To include inferred subtypes from the extended table of the base table of the Subtype Group in it, it is necessary to define in the Group a subtype of the foreign key through which they are inferred.
See also
When to use Subtypes
Videos
What are Subtypes?


"
55,When to use Subtypes,"https://wiki.genexus.com//commwiki/wiki?2213,When+to+use+Subtypes","Rule of thumb: don't use subtypes unless they are needed.

GeneXus uses the Universal Relation Assumption (URA), which says that one attribute has the same name everywhere. For example, the Customer's number is CustomerId in the Customer Transaction AND in the Invoice Transaction. However, URA can't be used in the following situations:
More than one relationship in the same Transaction.
Self reference.
Unnecessary integrity constraints.
Inheritance.
Therefore, in these cases the use of Subtype Group object is mandatory.
More than one relationship in the same Transaction
The canonical example is the Airport/Flight Transactions relationship. The Flight Transaction has two relationships with the Airport Transaction: one that defines which is the Departure airport and another one for the Arrival airport. The model is:
Airport
{
  AirportId*
  AirportName
}

Flight
{
  FlightId*
  DepartureAirportId
  DepartureAirportName
  ArrivalAirportId
  ArrivalAirportName
}

Departure Subtype Group
  DepartureAirportId   subtype of AirportId
  DepartureAirportName subtype of AirportName

Arrival Subtype Group
  ArrivalAirportId     subtype of AirportId
  ArrivalAirportName   subtype of AirportName
Note that there exists an alternative design that doesn't need the use of subtypes:
Airport
{
  AirportId*
  AirportName
}

Flight
{
  FlightId*
  {
      FlightAirportType* (Arrival or Departure)
      AirportId
      AirportName
  }
}
This design isn't very common, probably because is a little more difficult to find both airport at the same time.
Self reference
Consider an old-style Company where each employee has only one boss. In this case the model is as follows:
Employee
{
  EmployeeId*
  EmployeeName
  ManagerId
  ManagerName
}

Subtype Group: Manager 
  ManagerId      subtype of   EmployeeId
  ManagerName    subtype of   EmployeeName
Unnecessary integrity constraints
Consider the following online broker model for tracking stocks:
Account
{
  AccountId*
  AccountName
}

Stock
{
  StockId*
  StockName
}

Trade
{
  TradeId*
  TradeTime
  AccountId
  AccountName
  StockId
  StockName
  TradeType  (buy or sell)
  TradeQuantity
  TradePrice
}
What the Trade Transaction does is to record all the stocks an account has traded. Now suppose you add a 'Watch List' functionality: creating a set of stocks that an account regularly wants to watch (or 'have in the radar', in stock trading slang). At first sight this can be implemented with the following Transaction:
BadWatchList 
{
  AccountId*
  AccountName
  StockId*
  StockName
}
The problem with this Transaction is that there is an integrity constraint between the Trade base table and that of BadWatchList, meaning that only the stocks in the watch list can be traded by the account. To avoid this unwelcome side effect, the correct Watch List Transaction is:
WatchList
{
  AccountId*
  AccountName
  WatchListStockId*
  WatchListStockName
}

Subtype Group: WatchListStock 
  WatchListStockId      subtype of   StockId
  WatchListStockName    subtype of   StockName
Probably a more intuitive way of viewing this case is: given an account it's necessary to track two different sets of stocks, those the account has traded and those the account wants to regularly watch. Since these two sets are not related (one can buy stocks that aren't in the watch list or watch stocks that haven't been traded), two different names for stocks are needed (subtypes).
Inheritance
Suppose it's necessary to store information about People, Students, and Employees. The point is that all Students are People (even though, some high school teachers would disagree with this proposition) and all Employees are People too (no joke here). The best way to model this situation is to define subtypes for Students and Employees:
Person
{
  PersonId*
  PersonName
}

Student
{
  StudentId*
  StudentName
  StudentUniversity
}

Subtype Group: Student 
  StudentId      subtype of   PersonId
  StudentName    subtype of   PersonName

Employee
{
  EmployeeId*
  EmployeeName
  EmployeeDateOfHire
}

Subtype Group: Employee 
  EmployeeId      subtype of   PersonId
  EmployeeName    subtype of   PersonName
People And Organizations Knowledge Base has a good example of this case.

See Types of Inheritance for more info on the subject.
Videos
Definition of Subtypes
"
56,Parallel Transactions,"https://wiki.genexus.com//commwiki/wiki?20209,Parallel+Transactions","Parallel Transactions is the name used for two or more Transaction objects with the same identifier (primary key).
For instance, when you have the following two Transactions:
Supplier
Client


{
{


   CompanyId*
   CompanyId*


   CompanyName
   CompanyName


   CompanyAddress
   CompanyAddress


   CompanyPhone
   CompanyPhone


   SupplierPurchasesAmount
   ClientDiscount


}
}

they are Parallel Transactions because they share the identifier: CompanyId.
What effect does this have?
GeneXus designs the database upon standardization criteria, so, it will create an only physical table in the database whose attributes will be those resulting from the merged attributes of both Transactions:
CompanyId*
CompanyName
CompanyAddress
CompanyPhone
SupplierPurchasesAmount
ClientDiscount

Then, GeneXus generates two different programs – each one with its own form, rules, events, properties, etc. – but they will have associated the same physical table where the data will be stored.
Thus, when executing the Supplier Transaction and entering a new company, with CompanyId=1, a record will be inserted in the COMPANY table with primary key value 1, and the values entered by the end-user in the CompanyName, CompanyAddress CompanyPhone, and SupplierPurchasesAmount attributes. What will happen with the ClientDiscount attribute – for this record? It will be empty because it is not present in the Supplier Transaction so the end-user can not enter a value for it.
Afterward, when executing the Client Transaction with the purpose of entering a new company, CompanyId=2, a record will be inserted in the COMPANY table with primary key value 2, and the values entered by the user in the CompanyName, CompanyAddress, CompanyPhone, and ClientDiscount. In this case, the SupplierPurchasesAmount attribute will be stored with an empty value.
Note that by executing any of the Transactions, the end-user will be able, for example, to query, update and delete any record present in the COMPANY physical table associated with both Transactions. Consider that because each Transaction is an independent object, it is possible to define different rules and events for each of the Parallel Transactions to define the desired controls and behavior.
Transactions may be parallel at several levels. The example above just mentioned one-level Transactions.
For example, you could have three transactions with the following structures:
Transaction “T1”
Transaction “T2”
Transaction “T3”


A*
A*
A*


B
C
E


C
D
{ M*


{ X*
{ X*
  N }


  Z }
  Y }

In this case, there is double parallelism: between the first level of the three Transactions (they all have the same physical table associated), and between the second levels of the first two Transactions (they share the same physical table). GeneXus will create the three following physical tables in the database:
T1
A*
B
C
D
E

T2
A*
X*
Z
Y

T3
A*
M*
N



"
57,Tables,"https://wiki.genexus.com//commwiki/wiki?7120,Category%3ATable","GeneXus uses Transaction objects to create a Knowledge Base from which a Database structure is designed for storing your Application’s Data. The Database consists of Tables (usually called files) and access paths (called Indexes), designed using the third normal form.
Each Table gets its default name from the name of the Transaction that originates it. So, if a Transaction has only one level, the Table name will be the same as the Transaction name. On the other hand, if the Transaction has several levels, the subordinated table names will be created by concatenating the Transaction name and the corresponding Level names.
Sample
Consider the following Transaction:
Company
{
   CompanyId*
   CompanyName
   Branch
   {
       BranchId*
       BranchAddress
       BranchPhone    
   }
}
The Tables that will be created in the Database will be called: Company and CompanyBranch.
See Also
Indexes
Table Editor
Videos
Normalization of Tables: A Case Study
"
58,Indexes,"https://wiki.genexus.com//commwiki/wiki?7121,Category%3AIndexes","GeneXus automatically creates indices that efficiently access Tables and permits a more efficient Referential Integrity control. There are three types of indices: Primary, Foreign, and User.

Primary Index:
Transactions



Foreign Index:



User Index:

In a relational database, indices are used for performance reasons, but it is always possible to access table data using any of its attributes. This is always true because it is possible to order a table based on any of its attributes whenever necessary. For example, by either creating a temporary index or by using the resources provided by the database you use.



"
59,Table Editor,"https://wiki.genexus.com//commwiki/wiki?3928,Table+Editor","The Table Editor lets you browse the structure of a table and its indexes. In the Structure selector, it is a read-only editor.

In the Indexes selector, you can add and remove user indexes. To do so, just right-click on the root element (or any tree element), and select the ""Add index"" option.

Once the window is opened, you can add user indexes. For this, you need to enter an index name (GeneXus suggests ""U"" as the first character, but this is optional).
Next, press ENTER and choose an attribute from the suggestions list.
After that, you can choose the index order in the Database table (Ascending by default).

Note: you can select many attributes for the index composition.






"
60,Procedure object,"https://wiki.genexus.com//commwiki/wiki?6293,Category%3AProcedure+object","Defines a program or routine that implements an algorithm, including database access, data updates, and printing.

Scenarios
1. A typical example is a list, where the procedure is meant to navigate some tables, reading the database, to obtain the output that is then displayed on the browser, in a PDF format. For example, in the context of a Travel Agency application, a tourist attractions list:

2. Another example: all the flights that were scheduled to take off from a given airport on a certain day must be postponed. To achieve this, a procedure must be programmed to navigate the flight's table, changing the departure date and time for the appropriate flights (in this case, no output is needed).
3. A third example is a process that increases the flight prices according to a rate set by the airlines.
4. And the last example could be a complex calculation (other than formula) that, for instance, needs to navigate some tables and possibly use certain functions, formulas, and transformations in order to obtain the desired result (for instance, the destination at which more passengers arrive in a period of time, considering all airlines).

Sections
A Procedure object has several sections that can be defined:
Source: This is the main section because it is where the code corresponding to the procedure logic is written.
Layout: In this section, you define the output presentation. Not every procedure is meant to have this kind of output (or any output). This means that if the procedure prints information, it is in this section where you have to design the corresponding output, specifying the information to be printed along with its format. The Layout in a Procedure can be seen as the Form in a Web Panel or Transaction.
Rules: Define some declarative aspects as the parameters received by the object, some default values for variables, etc.
Conditions: In this section, you define conditions to be matched by the data to be retrieved (general filters).
Variables: Like most objects, it also has a section for defining variables, that are local to the object.
Help: A detailed description can be written for the procedure, to act as online help for the end-user at execution time
Documentation: A detailed description of the procedure can be written in order to document it.
Like most objects, it also has a Properties Editor to configure general aspects of the object: some apply to all objects, such as the name, others are specific to procedure objects, such as the kind of output (only to file, printer, etc), the call protocol when the object is main, etc.
Summing up, a procedure can be classified according to whether the focus is on:
Generating a visual output (typical listings or reports). Here the Layout section is mandatory.
Updating the database (insert, update, delete records of the tables, directly or with the help of Business Component ).
Doing complex calculations, having a non-structured output (although it is also possible with a procedure, a hierarchical output is best and easier achieved with a Data Provider object).
Note: As its name suggests, the programming style supported is imperative, although there are also declarative parts (ie: the Layout).
Example
Suppose you need to define a PDF report in order to list the airlines a Travel Agency works with. The procedure that implements this requirement could have the following Layout (for a complete explanation go to Procedure Layout):

And the logic could be:
Header
    Print Pb_Header
End
For each Airline
    Print Pb_Body
Endfor
...where the Header command provides the header that each page of the resulting report will have, the For Each command is used to access the database, and the Print command is the command that prints the Layout's called print block in the output.
Note
When a Procedure is declared Main Object, it will be generated with the prefix ""a"" as follows: aProcedureName (.Net and Java only).
Videos
Introduction to For Each command to access the database
 Database update using procedures. An introduction


"
61,General concepts,"https://wiki.genexus.com//commwiki/wiki?5489,Category%3AStatic+reports","Static reports are non-interactive database listings. It means when the information is extracted from the database it is displayed with no interaction with the end-user (the data is queried from the database and shown, and the end-user cannot modify the shown result).
A static report can be easily created by defining a Procedure object with a visual output. The output can be a printer, a file, or the screen.
It is important to take into account that the following requirements must be set in the procedure in order to run it as a PDF report.



"
62,Layout,"https://wiki.genexus.com//commwiki/wiki?5468,Procedure+Layout","If you need to generate a visual output in a Procedure object, you have to access to the Procedure Layout section in order to define the data to be listed and the output format.

By default, the Layout section contains a first printblock (named: printBlock1), which is empty and ready to be used. Inside it, you can include whatever you want to show.
Suppose you have to define a procedure in order to list all the airlines a Travel Agency works with.
Since the procedure Layout is composed by one or several printblocks (that do not necessarily have to respond to the same order as required for the output), each printblock must have one single name to be referenced from the Procedure Source (by using the Print command).
In the example, the first printblock will contain a logo, a title, the current day and hour, the page number, labels with titles and a line. So, insert those controls inside the printblock and rename it as ""Pb_Header"" (by modifying the printblock Name property).

Observe the elements that were added to the ""Pb_Header"" printblock. Most of the actions were achieved through drag&drop from the available Toolbox for this section:

and by setting the controls properties.
In particular to insert the logo, the Image icon has to be dragged from the Toolbox to the printblock and a dialog is opened offering you some possibilities, such as import the image from a file.
The system variables such as &Date, &Time and &Page, can be inserted by selecting: Insert > Variable...  from the Menubar or by dragging and dropping the Attribute/Variable control from the Toolbox.
Inserting Printblocks
Inserting printblocks is very simple. To do so, you have to right-click on a specific printblock and select from the context menu the Insert Printblock option. This action will insert a new printblock below it.

Look at the following figure. The second printblock has been inserted in the Layout section and the AirlineId and AirlineName attributes have been added to it.

To change a printblock's position, the context menu offers the Move Up and Move Down options.
Aligning and Resizing Controls
To align several controls at once (or to make them the same size), select them by holding down the Ctrl (or Shift) key and clicking on the desired controls. The last one (which will have its selection nodes highlighted in bold) will be the reference control for the action. Then, you only have to right-click and select from the context menu the option you are needing.

Inserting a variable based on an SDT
You can also insert in any printblock a variable that is based on a Structured Data Type. The options to insert it in the printblock are the same as for any variable. A dialog will be opened so that you can select which members you want to include in the printblock. One control for each member will be inserted and their FieldSpecifier property (which is mandatory) is for setting the collection position to be shown.
Invoking the Printblocks
Remember the procedure logic is written in the Procedure Source and from there, the Printblocks defined in the Procedure Layout must be invoked using the Print command:

Note that:
The For Each command is used as in any procedure to navigate in this case the Airline table and one of the printblocks is referenced inside it in order to print the scanned data.
The other printblock is referenced inside the Header command in order to be printed at the top of each page.
Layout Properties
You may access another set of properties (such as paper height, width, orientation, and so on) by clicking on the arrow in the upper left-hand corner of the layout window:

Note
In most cases, procedures with Layout are defined in order to print PDF outputs. Therefore, the following simple requirements must be set for the object.
See Also
Printing Commands Summary
Videos
Lists and For Each command to query the database
"
63,Source,"https://wiki.genexus.com//commwiki/wiki?6664,Procedure+Source","The Procedure Source is the section where the code corresponding to the Procedure object logic is written.
The style of programming is procedural (imperative) so the source will be a succession of statements (commands) where the order is important. The order in which they are specified will be the order in which they are executed, with some exceptions.
E.g.: Suppose you need to define a process to increase (by 15%) the salary of all the employees who have been working for more than ten years in the company. Therefore, he/she defines the following Procedure with the shown Source:

As you can see, next to the For Each command a Base Transaction is specified (Employee). As a base transaction is the name of the transaction whose related physical table you want to navigate, GeneXus will determine to navigate the Employee physical table (which contains all the information of each company employee, including the attributes EmployeeSeniority and EmployeeSalary). Besides, GeneXus will determine to filter those employees whose seniority exceeds 10 years and then, their salary will be updated, raising it by 15 percent.

As in any imperative language, in the Procedure's Source the following types of commands are available:
Control commands to implement conditional execution: If, Do case,
Repetitive commands: Do while, For in,
Ways to invoke another object: Call,
Sentence to break the iterations in a loop: Exit,
Sentence to leave the program returning to the caller: Return, etc.
...as well as specific commands with the following objectives:
Print a printblock defined in the Procedure Layout: Print command
Access and/or update the database: For Each command  (There is no specific update command; within the same command you read attributes values and you can update them, too).
Create a new record in a table: New command
Delete records: Delete command
Invoke a subroutine: Do command, etc.
Subroutines can be defined at the end of the Source and invoked from the desired place of the code, using the appropriate command (Do).
It is also possible to write to the database using the Business Component concept. See Update the database directly with commands VERSUS using Business Components.
Sometimes Procedures are needed to print data as well. To learn about printing see Procedure Layout.
See Also
Commands in Procedures
Source Code Editor



"
64,Database update through procedures,"https://wiki.genexus.com//commwiki/wiki?6826,Category%3ADatabase+update+through+procedures","When the database is updated through Procedure objects, records are inserted, updated or deleted from the tables through commands written inside the Source code of the Procedure.
There are two possibilities:
Direct update (through specific commands)
Update through Business Component
For a discussion about the differences between the two, see Update the database directly with commands VERSUS using Business Components.
Direct update
The update is achieved through the corresponding specific commands.
Insertion through the New command
Update through the For Each command
Deletion through the Delete command (inside a For each command)
Videos
Updating with procedure-specific commands. Introduction
"
65,New command,"https://wiki.genexus.com//commwiki/wiki?6714,New+command","Procedures include a command called New to insert records in a table. Using this command, you can assign values to the attributes of one physical table.

It is a low-level command, used to insert a New Record in a table. Since the New record modifies the database, it is only suitable for the Procedure object, not even for the Transaction object, where the addition is performed differently.
Note: Reading the paper ""GeneXus and Relational Databases: the Essence"" by Breogán Gonda and Nicolás Jodal is highly recommended.
Example
There is a “Product” Transaction for saving the information related to the products managed in a system, with its corresponding price list. The structure is as follows:
Product
{
   ProductId*
   ProductDescription
   ProductStock
   PriceList
   {
     ProductPriceListDate*
     ProductPriceListPrice
   }
}
Based on this, GeneXus creates two tables: PRODUCT and PRODUCTPRICELIST, each one corresponding to a level in the structure. The last one, PRODUCTPRICELIST, will have three attributes: ProductId, ProductPriceListDate and ProductPriceListPrice, with Primary Key {ProductId, ProductPriceListDate}.
Suppose you want to implement a Procedure object so that the product whose code is received as a parameter adds the new price (also received as a parameter) to its price list, for the date when the procedure is executed. Therefore, within its rules section, the Procedure will include the following:
Parm( in: &ProductId, in:&price );
In Source, type the following:
New
    ProductId = &ProductId
    ProductPriceListDate = &Today
    ProductPriceListPrice = &price
EndNew
Note that within the New command there are assignment commands, where each attribute in the table where the record is intended to be inserted is given a value. In this case, you want to add a record in the PRODUCTPRICELIST table.
Also, read a detailed explanation of the concepts behind the example.
Syntax
New
   [Defined by attributeList]
   [Blocking NumericExpression]
             BodyCode
[When duplicate
   { AnotherCode |
       For each
         {att = exp}
         …
       Endfor
     | AnotherCode } ]
 EndNew
Where:
attributeList
    A list of attributes (comma or space-separated) used to determine (together with the attributes on the left in an assignment inside the BodyCode) the table where the record will be added.
NumericExpression
    The 'blocking factor.' Its presence activates the Block (Batch) insertion mechanism and controls the number of records to be added per block.
BodyCode
    A sequence of commands, most of which, if not all, will be the form assignment:
att = exp
where:
    att
        Attribute to assign (for the record to be added).

    exp
        The expression assigned can be an Attribute, Variable, Constant, Function, or Arithmetic Expression (Date and Numeric type only).
When duplicate
It specifies the code to be executed when a duplicate record is detected (when a record with the same primary key or candidate key already exists in the table). Most times, some attributes of that existing record need to be updated. In these cases, a For Each command must be used, and the attributes to be updated are assigned within it. Even though it's not so common, other commands can be executed as well (AnotherCode).
Note: If there is a Blocking clause, When Duplicate commands are executed after an attempt to insert the entire block and a duplicate record is found. In this case, an insertion attempt is made for each record in the block; all the records may be successfully inserted, or 'When duplicate' commands may have to be used. See an in-depth explanation of Block (Batch) insertion mechanism.
Description
The extended table concept is not used here –  the command works by adding a single record in a single physical table, determined by the attributes in the BodyCode together with those in the 'Defined by' clause, if applicable. Duplicate keys are checked in primary and candidate keys. Even if the command has the Blocking clause, it adds a single record in a single table. The blocking clause only improves performance when the New command is inside a repetitive structure, not in a loop.
If an assignment to an attribute that doesn't belong to the base table is detected within a New command, an error is shown in the Specification report, and the program is not generated.
The New command can be included in other iterative structures, such as Do while, For Each command, For to step, which allow for batch insertions (here, the Blocking clause improves performance). Many New commands can be concatenated one after the other as another way to insert multiple records. Also, New commands can be nested.
How does GeneXus determine 'the table' of the New command?
Every time GeneXus finds a “new” command, it must identify the table where the records will be inserted. This table is identified based on the attributes in the BodyCode block of the “new” command (not the When Duplicate clause), on the left in an assignment, together with the attributes included in the 'Defined by' clause, if it exists, and it’s referred to as the base table of the ""new"" command. GeneXus will look for a physical table that contains all these attributes. If this table doesn't exist, an error message describing the issue will be displayed in the navigation report after the procedure specification, and the object will not be generated.
Do all attributes of the base table have to be assigned inside the New command?
Not necessarily. What happens to a record to be added depends on the context, when the table attributes are not explicitly assigned inside the BodyCode of the New command.
If the attribute is not instantiated: it will be empty (or null, depending on the corresponding property of the attribute) for the record to be added.
If the attribute is instantiated: the attribute, in the record to be added, will take the value of that attribute in the context, at the moment the addition is made.
What does context mean?
If an attribute is received as a parameter, its scope is the entire code. It keeps its value everywhere it is mentioned or needed.
If a command (such as New) is inside another (that is, in the scope of the latter), all the attributes 'instantiated' in the latter are in the 'context' of the former. For example, if a New command is inside a For Each command, all the attributes of the For Each command's extended table are in the context of the New command. What does it mean? For example, suppose a For Each command is iterating the Customers table and, after some calculations, a New command is added to its code, trying to insert for the current customer a record in a summarizing customer table. If the New command doesn't have an explicit assignment for the CustomerId attribute, its value will be taken from the For Each command (its context).
What happens if the primary key or any candidate key already exist?
The commands specified within the BodyCode block of the New command are not executed for that record.
The When duplicate command can be used to specify the action to be executed when duplicates are detected. All commands, between When duplicate and Endnew are executed when a Duplicate Key is detected during insertion.
A GeneXus variable: &ERR, could be created and if so, is set to code = 1.      
A GeneXus variable: &ERRMSG could be created, and if so, is set to a message.          
If the record to be inserted already exists and you want to update data in this record, a For Each command must be specified within the 'When duplicate' clause.
See the above note about the 'Blocking' clause.
When is the insertion performed?
It depends on the presence of the 'Blocking clause'. If it doesn't exist, the insertion will be performed at the end of the command (when the Endnew is reached). Otherwise, the actual insertion will be performed at the end of the block. Suppose the New command has a blocking factor N and is inside a repetitive structure (such as a For Each command). Every time the For Each command body is executed (and the New command inside it), the record of the New is not actually inserted, but is added into a memory block (a buffer) of size N. Afterwards, if the buffer is filled, a special insert (of many rows) is sent to the database, in order to insert the entire block. Then, if some of the N records to be added are found duplicated, the special insertion fails, and a one-by-one insertion is done, running through the N block, using the simple insert command.
Calling other programs within a New command
If you call another program within a New command (whether you use Call] or Udp), the call is always executed, even if the key already existed.
Example
New
    A = 1
    B = 1
    Calculation.call()  //The call method can be omitted. You can write: Calculation()
When Duplicate
    For each
         B = 2
     Endfor
EndNew
The “Calculation” Procedure is always called even if the key of the record to be inserted already existed in the table and the call is placed before the When duplicate clause. This behavior occurs because the Call command can be used to fetch some values to assign to the attributes.
Notes
Referential Integrity is NOT checked during insertion.
Redundancy will NOT be automatically maintained during insertion in Procedures. This maintenance is the programmer's responsibility. That is, if redundancy has been defined for an attribute in the table you are inserting, GeneXus will not search or calculate data to store in that attribute. In case of a Formula Redundancy, the Formula will not be available and the value must be calculated explicitly and assigned to the associated attribute.
Scope
Objects   Procedure object
See also
When duplicate clause
Blocking clause in a 'For each' command
Videos
Updating with procedure-specific commands. Introduction
"
66,Delete command,"https://wiki.genexus.com//commwiki/wiki?6828,Delete+command","Deletes the record(s) in the Base Table associated with the group where this command is specified.
Syntax
Delete
Scope
Objects: Procedure
Description
This command is used to delete records in the Base Table associated with the group where the Delete command itself is specified.
This command can only be used in a For Each command defined in a Procedure. The deletion is executed at the exact moment it is found, unless the For each command has a Blocking clause. In this last case, the current deletion will happen when the entire block is completed and the Delete command is sent to the DBMS for a bulk deletion.
Notes:


Referential Integrity is NOT automatically checked when the Delete command is specified.


If the Delete command is specified in a group that has nested groups, data in the current group can still be used in the inner nested groups despite having been physically deleted.



Remember to delete the inner levels first, before the outer levels. This avoids any possible cancellations or locks.


Samples
Given the Transaction objects:

PurchaseOrder
{
  PurchaseOrderId*
  PurchaseOrderDate
  SupplierId
  PurchaseOrderAmount
}

PurchaseOrderDetail
{
  PurchaseOrderId*
  PurchaseOrderDetailId*
  PurchaseOrderDetailQuantity
  PurchaseOrderDetailPrice
  PurchaseOrderDetailAmount
}
1) In the following example, purchase order lines are deleted before the purchase order header. So, there would be no purchase order lines left without a header if the program were to cancel.


For each PurchaseOrder           //As the base trn is PurchaseOrder the deletion will be perfomed in the PurchaseOrder table
   For each PurchaseOrderDetail  //As the base trn is PurchaseOrderDetail the deletion will be perfomed in the PurchaseOrder table
         Delete
   Endfor
   Delete
EndFor

To learn how to improve the throughput of bulk deletions, see Blocking clause in a 'For each' command or the general concept on Blocking Data Updates.
 
2) The following example, deletes a specific purchase order received by parameter.

Procedure Rule:
Parm(&PurchaseOrderId);

Procedure Source:
For each PurchaseOrder   //As the base trn is PurchaseOrder the deletion will be perfomed in the PurchaseOrder table 
    where PurchaseOrderId=&PurchaseOrderId
    For each PurchaseOrderDetail //As the base trn is PurchaseOrderDetail the deletion will be perfomed in the PurchaseOrder table 
        Delete 
    Endfor 
    Delete 
EndFor 

See Also
Database update through procedures
Videos
 Updating with procedure-specific commands. Introduction"
67,Blocking Data Updates,"https://wiki.genexus.com//commwiki/wiki?5572,Category%3ABlocking+Data+Updates","


When throughput is an issue and you need to update, insert or delete a large number of records, reducing the number of roundtrips to the DBMS may be the answer.

Blocking database update operations (generic for insert/update/delete) entails storing them in memory and sending them in groups to the DBMS. Instead of interacting with the DBMS on every database update operation, interaction takes place only every N update operations, where N is a number specified by you.
Say, for example, that you have to print all the invoices that have not yet been printed, and that the InvoicePrintedFlag is used to store printing status. The corresponding code should look something like the one shown below. This code reads matching records and updates them one at a time. Every time the EndFor is reached (one iteration) a record is sent to the DBMS to be updated.
For each
     where InvoicePrintedFlag = 'N'
       PrintInvoice.Call( InvoiceNumber )
       InvoicePrinterFlag = 'Y'
EndFor
Adding the Blocking clause, like in the code below, reduces the number of roundtrips to the server. In this case, a set of database updates are sent to the DBMS only every 100 times the EndFor is reached. This is usually faster than the previous code.
For each
     where InvoicePrintedFlag = 'N'
     Blocking 100
         PrintInvoice.Call(InvoiceNumber )
         InvoicePrinterFlag = 'Y'
EndFor
The same happens when inserting a large number of records in a repetitive code such as the following:
For &i = 1 to &j
       ...
       New Blocking 100
             Att1 = ...
             Att2 = ...
       EndNew
EndFor
Scope
This clause is not supported by the following platforms:
Java - Db2 udb
Net - MySql
Net - Informix
Net - Postgresql
NetCore - Postgresql









"
68,Call method,"https://wiki.genexus.com//commwiki/wiki?16224,Call+method","Calls a GeneXus object (either with transfer of parameters or not) such as a Web Panel or a Procedure, etc., from another object (which is the caller).
Syntax
ObjectName.Call([parm1, .... , parN])
Where:
ObjectName
     Is the name of the object you want to call.
par1, …, parN
     Are optional parameters that can be sent to the called object with some purpose (and they must be received in the called object by declaring them with the Parm rule).
Scope
Objects:   Procedure, Transaction, Web Panel, Panel
Description
The Call method can be written in different sections of the caller object, depending on whether the caller is a Transaction, a Web Panel, a Procedure, etc. (if the caller is a Procedure, the Call method must be included in some line of its Source; if the caller object is a Transaction, the call can be included in its Rules section as well as inside an Event, depending on the requirement, etc.).
Note: The syntax of the Call method allows you to omit the dot and the Call, and the invocation will be exactly the same, as GeneXus has the intelligence to detect that you are calling an object.
Samples
Example 1
Suppose you have a Web Panel in your Knowledge Base, that only has a button included in its form. When the user presses the button, the event associated with the button is executed and the objective is to call a Procedure that prints all the customers. So, you define the following code inside the event associated with the button, to achieve the objective:
Event 'Print all customers'
    PrintAllCustomers.call()
EndEvent
The following code behaves exactly like the above:
Event 'Print all customers'
    PrintAllCustomers()    //the dot and the call were omited
EndEvent
In both examples, the Procedure named PrintAllCustomers is called without parameters (so, no Parm rule is needed to be defined in the Procedure).
Example 2
Now suppose the Web Panel has a Dynamic Combo Box in its form, that shows all the countries stored in the database. And the button is also present in the form. The user will select a country and after that, he will press the button. The objective in this case, is to call a Procedure that prints all the customers who belong to the country selected by the user.

When the user selects a country, the CountryId attribute value will be assigned to the &CountryId variable associated with the Dynamic Combo Box. After that, when the user presses the button, the event associated with the button will be executed.
So, inside the event associated with the button, you have to define the invocation to the Procedure. In this case, you have to send to the Procedure the &CountryId variable as a parameter. The Procedure will receive the parameter (you must declare the parameter in the Procedure with the Parm rule); finally, you will use the received value in the Procedure, in order to filter the customers that belong to that country.
The following code inside the event associated with the button, is calling the Procedure named PrintCustomers, and the &CountryId variable is sent to it as a parameter:
Event 'Print customers'
    PrintCustomers(&CountryId)    
EndEvent
The Procedure must have defined the following rule:
parm(&CountryId);
and the &CountryId variable is used in the Procedure source in order to filter the customers that belong to that country, like the following code shows:

Note: For Smart Devices objects, the Call method must be written in the Native Mobile Applications Events.
See Also
Udp method
Videos
Communication between objects


"
69,UDP function,"https://wiki.genexus.com//commwiki/wiki?8517,UDP+function","Note:  For GeneXus 9.0 or higher versions, use the Udp method.

The UDP (User Defined Procedure) function, is used to call a GeneXus object with a particular feature: it will return necessarily a result to the object that called it.
Syntax
&VariableName|AttributeName =UDP(ObjectName[,par1 , ..., parn])
Where:
&VariableName
    Is the name of a  variable defined in the caller object. It will receive the data returned by the invoked object with the UDP function.
AttributeName
    Is a valid attribute name defined in the knowledge base. It will receive the data returned by the invoked object with the UDP function.
ObjectName
      Is the name of the object you want to invoke, using the UDP function.
par1, …, parn
      Are optional parameters that can be sent to the called object with some purpose (and they must be received in the called object by declaring them with the Parm rule.
Example
The following invocation using the UDP function, is used to call a procedure that calculates the number of points of a certain pilot in an airline company:
&TotalPoints = UDP(PCalPts, PilotNbr);
In the rules section of the CalPts procedure, the following parm rule must be declared:
Parm(PilotNbr, &TotPts);
The first parameter declared inside the Parm rule is the received parameter. And the last parameter corresponds to the one that it's value is calculated in the procedure, and assigned to the &TotalPoints variable which is before the equal sign in the invocation.

See Also
Udp method
Parm rule
Definition of type of parameters received (in, out, inout)
"
70,"Definition of type of parameters received (in, out, inout)","https://wiki.genexus.com//commwiki/wiki?8220,Definition+of+type+of+parameters+received+%28in%2C+out%2C+inout%29","Each parameter declared in the Parm rule can be defined to operate as:

input parameter (specifying the in operator)
output parameter (specifying the out operator)
input and output parameter (specifying the inout operator)

When no operator is specified, it will depend on the following:

If the object was called with Call, the parameter behavior will be: inout.
If the object was called with Udp, and it's the last parameter, it will be an out parameter.

Syntax
parm([out:&var1, in:&var2, &var3, inout:&var4]);
Where:
&var1, &var2, &var3, &var4:
    Are -local and temporary- variables defined in the called object.

Example
The following rule is declared in a procedure:  

parm(out:&var1, in:&var2, &var3, inout:&var4);
So, note that:
&var1: Is an out parameter
&var2: Is an in parameter
&var3: Is an in-out parameter
&var4: Is an in-out parameter
 
Advantages of defining operators
Declaring explicitly each parameter behavior, you obtain the following advantages:
1. A better specification of the semantics of the interface. This means that the following will be understood:

inout: the parameter comes with a value and after executing the called object,  the resulting value is returned to the caller object.
in: the parameter comes with a value and after executing the called object,  the resulting value is not returned to the caller object. (*)
out: the parameter doesn't come with a value and after executing the called object, the resulting value is returned to the caller object.

2. Independence from generation languages. That is if you specify operators explicitly, whenever applications are generated using different generation languages, the behavior of the parameters will not change based on the default behavior of the corresponding generation language.
3. Input variables are also considered read-only. They will be read-only in the Layout, and if you try to change them in some way in the code, you get an SPC0022 warning in specification time.
Considerations
The specifier will not allow specifying a program assigning values (in rules/source/events) to parameters defined as in.
(*) When the variable is a complex type (such as a Business Component, Structured Data type, External Object) the parameter is passed by reference.
Videos
 Invocations between objects
 Invocations between objects (Cont.)"
71,For Each command,"https://wiki.genexus.com//commwiki/wiki?24744,For+Each+command","Retrieves a dataset from the database. When used in Procedure objects, besides reading the database, it can also be used to update it.
Syntax
For each [<BaseTrn1>|<BaseTrn.Level1>,...,<BaseTrnN>|<BaseTrn.LevelN>]
         [SKIP <NumericExpression> COUNT <NumericExpression>]
         [order <Att1>,...,<AttN> [when <Condition>]]...
         [order none [when <Condition>]]...
         [using <DataSelectorName>([<parm1>,...,<parmN>])]...
         [unique <Att1>,...,<AttN>]...
         [where <Condition> [when <Constraint>]]...
         [where [not] <Att> in <DataSelectorName>([<parm1>,...,<parmN>])]...
         [blocking <NumericExpression>]
                   <MainCode>
         [When duplicate
                   [<CodeWhenDuplicate>]]
         [When none
                   [<CodeWhenNone>]]
Endfor
View Syntax conventions
Where:

BaseTrn1|BaseTrn.Level1, ..., BaseTrnN|BaseTrn.LevelN
     Is a Transaction or Transaction.Level name (or several separated by commas) to be used as the base table for the For Each navigation. See more on Base Transaction clause.
SKIP
 Determines the number of records omitted from the output. Skip takes positive values.
NumericExpression
     Specifies the number of records in each block.
COUNT
Determines the number of records that will go to the output. If Count takes the value 0 or less, it means no limit.
order
     Allows indicating the order in which the query will be returned. As the syntax indicates, you can write many conditional order clauses.
Att1,...,AttN
     It is a list of attributes separated by a comma. Each mentioned attribute must be a knowledge base attribute that may be written with or without round brackets. When an order attribute appears between round brackets, it indicates a descending order for this attribute.
when
     Specifies when the condition for data retrieval or the order of data displayed will be used.
Condition
      Specifies any valid logical expression that conditions the data retrieval. It can be a compound condition, using 'and', 'or' and 'not' logical operators.
Order None clause
       For cases in which you are not interested in a particular order and want it to remain undefined.
using
 Allows ordering and filtering according to the criteria set out in the Data selector specified by its name DataSelectorName.
DataSelectorName
     Is the name of the Data Selector.
parm1, …, parmN
     Are variables defined in the called object or attributes.
Unique
 Returns only those records where the set of values of the referred attributes is unique.
where
 Allows indicating a list of conditions that must be matched by the data in order to be processed within the For each (inside the MainCode). The conditions are boolean expressions, simple ones or very complex nested ones.
Constraint
 Is a condition that specifies when the where clause will apply.
Att
It is an attribute that must belong to the extended table of the Data Selector base table.
blocking
Available in Procedures (when updating/deleting). It indicates the number of records that will constitute a database block, when you are updating or deleting, in order to reduce the number of roundtrips to the DBMS.
MainCode
It is the list of commands.
CodeWhenDuplicate
Available in Procedures, when inside MainCode certain attribute is updated (overwritten) and there exists a unique index for it. When you intend to overwrite the record with a previously existing value, this code will be executed instead of MainCode for that record. See more on When duplicate clause.
CodeWhenNone
When there is no data meeting the filter conditions, the MainCode commands will not be executed; the CodeWhenNone commands will be executed instead. See more on When None Clause.
Note: Even though the Defined By Clause from previous versions of GeneXus (located between ConditionList and BlockingGroup in syntax) is allowed, it becomes meaningless against the Base Transaction clause.
Description
Throughout any application, you may need to retrieve information from the database in a procedural way.
For this, GeneXus offers the For Each command to be used to get a dataset from the database. When used in Procedures, besides reading the database, it can also be used in order to update it.
You can define For each commands in:
Procedure Sources
Web Panels, Work Panels or Panels Events
Subroutines
Within a For each command you can define the information you want to read (also write if inside a Procedure object).
Samples
Consider the following Transaction objects:
Customer
{
   CustomerId*
   CustomerName
   CustomerAddress
   CustomerPhone
   CustomerEmail
   CountryId
   CountryName   
}

Country
{
   CountryId*
   CountryName
}
Suppose you want to display some information about the customers. To do so, you can define the following Procedure Source:
For each Customer   //Customer is the name of the Transaction. So, Customer is the Base Trn of the For each.
    Print Customers 
Endfor
""Customers"" is the name of the following printBlock defined in the Procedure Layout:

With this For each command (which contains a Print command to show customers data) you are indicating you want to query the Customer table as the Base table and its Extended table to display the code, name and country of each customer in the database.
Every time there is a For each command, you are specifying that you want to get some information from the database and for each record retrieved you want to do something with the associated information (for example: print it).
Base table
So, all for each command by default will navigate one table, which is known as the For each Base table. It is the table associated to the Base Transaction. A special case arises when using more than one base trn.
In the example above, the For each Base table to be navigated is CUSTOMER. And for each navigated customer, his/her country is obtained from the COUNTRY table.

For any For each command, GeneXus will navigate a Base table, but can access all tables that belong to the Extended table of that base table, in order to get the necessary information. That is why in the example above the base table is CUSTOMER, but for each customer GeneXus can get its related country (because the COUNTRY table is included in the CUSTOMER's extended table).
Extended table
Although you can specify a Base Transaction starting point for the search (it is strongly recommended to do so), it is not mandatory:
When a base Base Transaction is specified, the Base table is directly determined. All attributes mentioned within the For each command code (including the attributes mentioned within the invoked print blocks), will have to belong to the corresponding extended table. If not, warnings will be displayed for each attribute not reachable from the Base table through the Extended table (""Att is not instantiated in group..."").
When not: considering the attributes defined inside the For each (including those mentioned within the invoked print blocks), GeneXus will find out how to retrieve them. How? Finding the least extended table that has all of them, and the base table of that extended table is the one chosen by GeneXus as the For each base table. You don’t need to define which tables they must be obtained from, nor the indexes that must be used to access them. We define which attributes are needed and GeneXus will find out how to retrieve them.
Specifying the Base Transaction, however, it is easier for GeneXus to understand what you want (and make it faster), and for you to be sure you have been clear and on control.
Optimizations
The boolean expressions in the where clause constraint the obtained dataset. However, there is a great difference between a full scan table access and an index-optimized random access.
By applying some rules of logic, GeneXus determines whether the order clause (or the primary key order) is compatible with the where boolean expression(s), optimizing the access to the table by using indexes and not doing a full table scan.
This is obviously the desired behavior whenever possible.
See Conditional Orders and Filters for further information.
Native Mobile and Angular applications
This command can be used when developing applications for Native Mobile Generators or Angular but with some considerations. It can only be used in Work With pattern and Work With object and Panel object and only in the System Native Mobile Applications Events, this means Start, Refresh and Load events.
See Also
Nested For Each commands
Videos
Introduction to For each command to access the database
 More on nested For eachs. Cases and navigation
 Syntax of the For each command
 Updating with procedure-specific commands. Introduction
"
72,Order clause,"https://wiki.genexus.com//commwiki/wiki?6075,Order+clause","Indicates the order in which the query will be returned. It applies to For Each command, Data provider groups, Data Selectors and grids.
Syntax
order <att1>, ..., <attN> [ when <Condition>] | {order none [ when <Condition>]...
Where:
att1, ..., attN
It is a list of attributes separated by a comma; each mentioned attribute must be a knowledge base attribute that may be written with or without round brackets. When an order attribute appears between round brackets, it indicates a descending order for this attribute.
Here you can mention extended table attributes and formula attributes. However, if you're working in a centralized platform you can only use the attributes stored in the for each Base Table. Formula attributes need to be evaluated in the server.
Condition
For centralized platforms, you can specify one order clause at the most, with no condition ('when'). For client/server platforms, you can define several conditional order clauses, and one unconditional order clause, which should be the last one listed; the reason for this is that as only one of these order clauses will take effect, their conditions (the when conditions) are evaluated one by one until the first True one is reached, which is the one that will be chosen. If none of them are found to be True and there is an unconditional clause (that is, one without a 'when'), the order taken will be that of the unconditional clause. If there is no such clause, the order will be undefined, which means that it will depend on the platform, and it may even vary from one execution to the next. The reason for writing conditional order clauses is motivated by query optimization.
order none
For cases in which you are not interested in a particular order and want it to remain undefined.
Do Order clauses determine the exact order really used by the DBMS in order to solve the query?
The final order that will be generated could be slightly different from that specified by the user because other considerations are taken into account by the GeneXus Specifier in order to optimize the database access.
Basically, the following information is considered to generate the order clause (the low level specification in the code):
Attributes of the order clause specified by the user.
Restrictions that apply to the level: attributes instanced by parameter, attributes instanced in the context (such as higher level for eachs, groups, grids), explicit conditions (such as 'where' conditions when for eachs or groups, or 'conditions' properties when grids or data selectors or 'conditions' selector when general conditions).
Existence of indexes on such attributes.
In summary, with the order clause, you indicate the order in which you want the records to be processed and retrieved, and they will. But to perform the actual processing, the Specifier could alter that clause, supplemented with contextual info (if there exists defined indexes, conditions for equality, etc) in order to be more performant, although DBMS itself ends up being the one who decides the execution plan. Nevertheless, it is important to understand the data will be retrieved in the explicit order. See the Order Clause Specification for more details.
Centralized Platforms
The above considerations do not necessarily apply to centralized platforms. In those cases, GeneXus searches for an index in the level's base table considering the attribute list. If it does not exist, a temporary index will be created every time the program is executed. As temporary index creation may be too slow in some cases, this is when the creation of a user index is recommended.
If no order is specified:
If level is nested into another level: GeneXus will try to find the index that matches all outer orders, optimizing performance.
Otherwise: the Primary Key of the Base Table will be chosen.
Note: Since GeneXus X Evolution 3 Help, the keyword ""order"" cannot be ommited in the order clause. See Base Transaction in For Each command for more information.
Videos
How to process grouped information
"
73,Where clause,"https://wiki.genexus.com//commwiki/wiki?8578,Where+clause","Indicates a list of conditions that must be matched by the data in order to be processed within the level —For Each command or Data Provider Group statement—. The conditions are boolean expressions, simples or very complex nested ones.
It is possible to specify more than one Where clause. In this case, the conditions are evaluated as if they were separated by an 'and' operator.
Syntax
{where   
{<condition> [when <constraint>]}  |  


 
{ [not]<attribute> in <DataSelectorName>( [<parameterList>]) }}...

Where:
<condition>
specifies any valid logical expression to condition the data retrieval. It can be a compound condition, using 'and', 'or' and 'not' logical operators.
Those attributes appearing in the boolean condition may be either from the for each Base Table or from its Extended Table. In some cases, attributes that do not belong to the extended table can be included. See Filters As Hint for more details.
The occurrence of n where clauses is equivalent to the occurrence of only one where clause, with the boolean conjunction of the conditions.
<condition> ::= 

[not] <condition> [ {or | and} <condition>]


 
[(] <condition> [)]


 
<relationalExpr>


 
<stringExpr> like <stringExpr>


 
<booleanFunctionExpr>
<relationalExpr> ::= 

<expr> [ {> | >= | = | < | <=} <expr> ]


 

<expr> is an expression. If used for comparison, its datatype has to allow comparison (i.e. numeric, character, etc.). It can also be an aggregate formula (inline) (i. e: count, sum, min, max, average).
<booleanFunctionExpr> ::= 

True | False | <bool_attribute> | <bool_variable> | <bool_function>( <expr> ) | <bool_proc>}( [<parametersList>] )


 

<bool_attribute>, <bool_variable> are attribute/variable of a Boolean datatype, respectively. 
<bool_fuction> is a function returning a boolean result (True or False). <expr> is an expresion of the datatype required by <bool_function>. 
<bool_proc> is a user-defined Procedure that returns a boolean value.

<constraint>
is a <condition> that specifies when the where clause will apply. In client/server platforms, the When clause of each where clause is first evaluated, and if its condition is met, the filter specified by the where clause will be applied. See more about When clause.
[not]<attribute> in <DataSelectorName>( [<parameterList>])
The Data Selector object determines a query itself. This means that a SELECT sentence will be generated for the Data selector definition, which will be a different and independent SELECT from the level one—For Each command or Data Provider Group statement—. Thus, it will return a collection of values corresponding to the same definition as the <attribute>. This <attribute> must belong to the extended table of the Data Selector base table. See more: Data Selectors in For Each command.
Conditions as properties
The same concept but with a slightly different syntax (for example, without the 'where' keyword) applies to Data Selectors, as well as 'Conditions' section of Web panels, Panel object and Work With pattern and Work With object, as well as grid 'Conditions' property.
Optimization
<Condition> in the where clause constraints the dataset that is obtained. However, more than that is meant here. There is a great difference between a full scan table access and an index-optimized random access. If applying some rules of logic, GeneXus determines that the order clause (or the primary key order) is compatible with the where condition(s), it optimizes the access to the table using indices and not doing a full table scan. This is obviously the desired behavior whenever possible.
The conditions that can be optimized are the ones that use the operators: '>', '>=', '=', '<' and '<='.
If the Where condition is optimized, it will appear as ""Navigation Filter"" in the Navigation report. Otherwise, it will appear as ""Constraint"".
Be sure that the conditions used in the where clause respect type definitions. If this is not the case, an error message indicating a type mismatch will be displayed.
See more about Conditional Orders and Filters.
Examples
1. Suppose you need to print the customer names for those customers who were born in a certain country and after a certain date.
For Each Customer
Where CountryId = &CountryId
Where CustomerBirthDate.year() >= &youngDate
    print youngCustomer //printblock with: CustomerName
EndFor
Note the code is valid only as of GeneXus X Evolution 3 because you have included the Base Transaction clause in order to specify the base table. Remember this is not mandatory, and you could not include it. In such a case, the code will be valid for previous GeneXus versions.
CountryId, CustomerBirthDate, and CustomerName belongs to CUSTOMER extended table. Note you have not specified an order. This will affect the performance as you can see in Conditional Orders and Filters.
2. Now suppose &CountryId is set by the end-user, by means of a web panel, for instance. As the user can let the variable empty, you need the filter will not be applied in that case:
for each Customer
where CountryId = &CountryId when not &CountryId.lsEmpty()
where CustomerBirthDate.year() >= &youngDate
    print youngCustomer // printblock with: CustomerName
endfor
3. If you need in several objects to filter the young customers of a certain country, probably you would have created a Data selector in order to define that query:

Thus, the previous for each would be:
for each Customer
where CustomerId in YoungCustomer( &CountryId, &youngDate )
   print youngCustomer // printblock with: CustomerName
endfor
4. Finally, you need to print the countries for which you have more than one hundred customers:
for each Country
where Count( CustomerName ) > 100
   print countryInfo //printblock with: CountryName
endfor
Note the For each base table is now COUNTRY.
Scope
Commands: For Each command, Xfor Each command, Xfor First command, Data Provider Group statement
See Also
Conditional Orders and Filters







"
74,Defined By Clause,"https://wiki.genexus.com//commwiki/wiki?8358,Defined+By+Clause","Defines the Base Table of the related command or statement.
Appears to solve some problems of ambiguity in the determination of the base table (when there are several minimum extended tables containing the command attributes) or when you want another Base Table, different from the one that would be determined by the attributes appearing in the rest of the command. It is also used to improve the specification time of complex reports; however, an indiscriminate use is not recommended. The disadvantage of using this clause when it isn’t necessary is that it ties the code a little more to the design of the Tables.
Syntax
Defined by <Att1,...,AttN>
Where:
Att1,...,AttN 
     List of attributes to determine the related Base Table.
Description
This command allows the user to define the Base Table of a For Each command, New command or Data Provider group explicitly. When defining Procedures/Reports/Work Panel, it is usual for attributes in commands to determine the Base Table. Sometimes, commands within the command do not determine exactly the Base Table (i.e. more than one table can be the Base Table), so it is necessary to declare it explicitly using this command. The attribute list will determine the base table with higher priority.
Notes:
This clause can only be specified immediately after a For each, Where, or other Defined by command.
The use of the 'Defined by' clause remarkably improves the program specification time, especially in large applications and in For Each or Data Provider groups with large extended tables.
See Some considerations on the Defined by clause in For each or Data Provider.
Scope
Commands: For Each command, Data Provider group
See Also
For Each command
Where clause
"
75,When None Clause,"https://wiki.genexus.com//commwiki/wiki?8603,When+None+Clause","Specifies the code to be executed when a For Each command or Xfor Each does not filter any record.
Syntax
When None
         <CodeWhenNone>
Description
It is often necessary to execute a certain code when a For Each or Xfor Each does not filter any record.
To simplify the logic of the For Each and to provide more programming clarity, the command When None can be used.
Note:
It is important to clarify that if For Eachs are included within a When None, neither joins nor any type of filter will be inferred with respect to the For Each that includes the When None command.
Example
Use of this clause is in the numbering procedure
For each
    where NumCode = &code
           &LastNum = LastNum + 1
           LastNum = &LastNum
    when none
           &LastNum = 1
           New 
                  NumCode = &code
                  LastNum = &LastNum
           EndNew
EndFor
In this example, you update the last number for the document specified by &code, If the record does not exist, you insert it in the table.
Scope
Commands: For each command (XEv2, XEv3), XFor Each, XFor First
See Also
For Each command - For Each command (XEv3)
XFor Each Command
XFor First Command








"
76,Structured Data Type,"https://wiki.genexus.com//commwiki/wiki?6286,Category%3AStructured+Data+Type","Largely known as Record, Struct or Structure in most programming languages, this GeneXus object allows you to define complex data structures. An SDT represents data with structures made up of several elements, such as a Customer struct.
SDTs make it easy to transfer parameters (more specifically, they allow you to provide/use structured information when using web services), they simplify XML automatic reading and writing, and make it possible to manage lists of elements of variable length.
See Also
Structured Data Type (SDT) object









"
77,Structured Data Type (SDT) object,"https://wiki.genexus.com//commwiki/wiki?10021,Category%3AStructured+Data+Type+%28SDT%29+object","Defines a compound data type that groups fields of other data types and collections.
Description
Largely known as Record, Struct, or Structure in most programming languages, GeneXus offers the Structured Data Type (SDT) object to allow defining compound data types.
A Structured Data Type (SDT) object represents data whose structure is made up of several members.
After creating an SDT object, you are ready to define its structure:

Also, instead of starting to define the SDT’s members one by one, you can drag a Transaction (in the example, the Customer Transaction) from the KB Explorer and drop it on the SDT structure. Thus, you obtain in the SDT structure the members automatically created with the same names as the attributes in the Customer Transaction with their data types:

You can define only variables based on SDTs. On the other hand, you cannot define attributes based on SDTs because attributes may only store simple data.
When defining a member in an SDT design, you must specify the Name property identifying the member; therefore, there cannot be two members with the same name. The Data Type property allows selecting among the following data types:
GeneXus Basic data types (Numeric, Character, Date, etc.)
GeneXus Domains
Another already defined SDT
The IsCollection checkbox allows you to define whether the member has multiple (several) instances or not.
See Also
Structured Data Type Properties
Structured Data Type methods
Structured Data Type editor
XML Information Properties (SDT)
Videos
Structured Data Types
"
78,Structured Data Type editor,"https://wiki.genexus.com//commwiki/wiki?6365,Structured+Data+Type+editor","How and where do you define the structure of a Structured Data Type (SDT) object?
By using the SDT Editor.
While creating a Structured Data Type (SDT) object, you may define a multilevel structure, similar to the Transaction's structure. Each level can have one or more members. These members may be classified into:
Simple Elements
Compound Elements (also composed of other elements).
In this article you will find:
Simple ElementsXML PropertiesCompound ElementsDifferent Actions over Each Kind of ElementCollectionSubstructureMemberExamples of SDT Serialization to XMLDefining a Collection Based on Any Data TypeSee AlsoVideos
Simple Elements
While defining a member in a Structured Data Type (SDT) object design, you must specify the following:
Name property: to identify the member. There cannot be two elements defined with the same name.
Data Type property: you may select between GeneXus basic types (Numeric, Character, etc), Domains, or another already defined SDT.
Is Collection property: to indicate whether the element has multiple instances (it can be repeated) or not. It has two possible values: True or False.
Look at the following image:

XML Properties
While working with SDTs you can define some properties related to each kind of element, in order to have control over the SDT serialization to different formats, such as XML. When working with a simple element (a member) you will see the following XML properties:
XmlType
XML Namespace
These properties allow you to have control over the XML that will be generated.

XmlType Property
This property may have one of the following values:
Element: This is the default value. The element (member) will be serialized as an XML Element.
Attribute: The member will appear as an XML attribute but in the last level of the parent element.
CData: The member will be serialized as an element with a CDATA. It is usually used with values that contain XML.
Value: The member will be the Value of the parent Element.
XML Namespace property
Compound Elements
They are those elements defining a new element group, a new collection, or a group of simple elements.
Different bullets, in the editor, identify the compound elements:
Identifies a member in an SDT
Identifies a collection
Identifies a structure, a group of simple elements
Compound elements have the same properties as simple elements, but the Data Type property is not enabled.
In the following example you can see a Structured Data Type named Customers with some simple and compound elements:

Now look at the corresponding Properties windows:

When a substructure defines a collection, besides the data type created with the SDT name, there will be another data type created with Name.SubstructureName, and they will be selectable as data types in any variable definition. This means that the two data types will be created. Following the example, while defining variables in a procedure, you may see:

Stop and take a look again at the image of the Collection properties window. Can you see the Collection Serialization property?

The purpose of this property is to help solve the problem of how to serialize a collection. Its possible values are:
Wrapped: Default value. Includes the collection start/end tag.
Sequence: Will serialize as a plain sequence of collection elements.
Different Actions over Each Kind of Element
As with any other editor, the SDT editor allows you to define actions over each kind of element by right-clicking on:
Structured Data Type
Collection
Member
Drag and drop: You can select a Transaction from the Folder View and drop it into the SDT structure. The Transaction structure will be added to the SDT structure.
Structured Data Type
By right-clicking on a Structured Data Type you will see the following secondary menu:

Insert Member: This allows you to insert a new member to the SDT structure.
References: Displays which objects refer to the Structured Data Type (SDT) object.
History: Displays all modifications that were done to the Structured Data Type (SDT) object (version, name, date, user).
Properties: Displays the Properties window.
Locate in Folder View: This shows you where the Structured Data Type (SDT) object is located within the Folder View / KB Explorer.

Note: When you need to insert a new member in the structure, you may use the corresponding option in this secondary menu shown above, or you may also drag the attribute to the structure. Look at the following image:

Another method for inserting members in the SDT structure is to use the Insert Menu from the GeneXus main toolbar.
The available menu options are :
Insert Attribute: inserts a member with the same name and with type based on the selected attribute
Insert Domain: inserts a member with the same name and with type based on the selected domain
Insert Object (only Transactions can be selected): inserts one member for each attribute in the Transaction structure, with the same name and type based on it. Note: If the description of an attribute of the Transaction changes, it also changes in the SDT structure (as since GeneXus 15 upgrade 3).
If the focus is on the SDT structure root, the new members added with the Insert menu will be placed on the end of the structure, if the focus is on one existing member, the new member will be added immediately after the selected one.
Collection
By right-clicking on a Collection you will see the following secondary menu:

Delete: Deletes the Collection.
Move Items Up: Moves the Collection up in the SDT structure.
Move Items Down: Moves the Collection down in the SDT structure.
Indent: Adds the selected collection under a new collection.
Unindent: Takes the selected collection away from its container collection.
Insert Member: This allows you to insert a new member to the collection.
Insert Sibling Substructure: This allows you to define a substructure under the SDT structure (under Customers, in the example above).
Properties: Displays the Properties window.
Substructure
By right-clicking on a Substructure you will see a secondary menu quite similar to the Collection menu:

Member
By right-clicking on a Member you will see a secondary menu quite similar to the Collection menu:

Examples of SDT Serialization to XML
1) Suppose that you have the following SDT:

You want to generate the following XML:
Richard Smith
So, you will need to set the following values to the corresponding properties:
XmlType property in Id member: attribute
XmlType property in Name member: value
2) Suppose that you have now defined an SDT like the one below:

The collection may be serialized as follows:
<Country>
       <Cities>
            <CityName>Montevideo</CityName>
            <CityName>Rocha</CityName>
            ...
        </Cities>
</Country>
In this case, the Collection Serialization property must be specified as Wrapped
Or as:
<Country>
    <CityName>Montevideo</CityName>
    <CityName>Rocha</CityName>
     ...
</Country>
In this case, the Collection Serialization property must be specified as Sequence
Defining a Collection Based on Any Data Type
By working with the SDT Editor, you may define collections as shown in the following image:

However, you will not be able to define a collection based on any Data Type (Numeric, Character, another SDT data type, BC, etc). In order to solve this situation, you must work with Collection Domains, or you may even define a Collection Variable based on the corresponding Data Type, as shown below.

See Also
Recursive SDTs Implementing SDT Collections
Videos
Compound data types
 Loading Compound Data Types (SDT) using Data Providers

"
79,Business Component,"https://wiki.genexus.com//commwiki/wiki?5846,Table+of+contents%3ABusiness+Component","The Business Component (BC) concept provides a way to use all the power of a Transaction object from other GeneXus objects.
It allows updating the database from any object, executing Transactions in a 'silent' mode (without showing its forms) but taking advantage of all the benefits offered by them!
Most important benefits
Database update guaranteeing data integrity
Less coding: The business logic defined in the Transaction is reused (rules and formulas are triggered, etc.)
All GeneXus objects can update the database: For example in a Web Panel object the only way to update directly the database (without calling a Procedure object) is using the business component concept.
Rest: A Business Component may be exposed as a Rest web service.
SOA interface: A Business Component may be defined as a SOAP web service, allowing updates via SOAP.
EJB: A Business Component can be defined as a Enterprise Java Bean so you can execute it in an EJB Container of any J2EE Server.
Business Component definition
Every Transaction offers the Business Component property to define it as a Business Component.
See Also
DB update using two-level business components
Videos
Data Population using Business Components and Data Providers
 Database Update Using Business Components
 Database Update Using Business Components – Example"
80,Transactional Integrity,"https://wiki.genexus.com//commwiki/wiki?45612,Transactional+Integrity","A set of the database’s updating has Transactional Integrity when, in case of an abnormal ending, the database remains consistent.
See Also
Logical Unit of Work (LUW)



"
81,Logical Unit of Work (LUW),"https://wiki.genexus.com//commwiki/wiki?7963,Logical+Unit+of+Work+%28LUW%29","A Logical Unit of Work (LUW) is a set of operations to the database that must be all or none of them executed.

The set of updates that defines a Logical Unit of Work ensures the database’s integrity at a logical level.

The DBMS is responsible for implementing the mechanisms for maintaining the Transactional Integrity, and the programs must indicate when the LUW begins and ends.
Example: Suppose there is an Invoices Transaction object consisting of two levels: header and lines. At the logical level, the entire Transaction object is a Logical Unit of Work (LUW) that includes the header as well as the lines, because if a failure occurs, the header should not be recorded without lines or the lines without a header.
Logical Units of Work (LUW) in GeneXus
Transaction objects: The Logical Unit of Work’s scope is defined, by default, as the entire Transaction. There is an implicit Commit at the end of the source generated by GeneXus that is executed after each Transaction instance (after recording the record that corresponds to the header and after recording all the records that correspond to the lines).
Procedure objects: The Logical Unit of Work’s scope is defined, by default, as the entire program. At the end of the source generated by GeneXus, a Commit is included.
A different scope can be defined by using the Commit command and Rollback command at any point in the program.
When do you need to use the Commit command for defining a different scope? For example, when you are managing a large volume of data and want to define smaller transactions in order to perform a commit after a certain number of records is processed.
See Also
Commit on exit Property


"
82,Data Provider object,"https://wiki.genexus.com//commwiki/wiki?5270,Category%3AData+Provider+object","Loads data in a hierarchical structure (from databases, services, fixed values, etc.).
Description
Applications increasingly need to interact by exchanging data. From an application in a travel agency, ticket requests have to be sent to an airline containing the passengers' information; from another application, a Google service has to be used or merely exchange structured data within the application itself.
In this scenario, handling structured data becomes essential. The format used to represent them is not and will not be homogeneous. While XML is the most widely used format today, other formats are emerging, such as JSON to lighten the transfer, and we don't know what the future holds.
A Data Provider is a 'declarative procedure' used to obtain data in a hierarchical structure, with maximum clarity and minimum effort. How? By making the intention clear, that is to say, the output. Then, by simply indicating the desired format of the output.

Anything that can be done with a Data Provider can also be done with a Procedure. Both can be seen as processes where there is an Input, a Transformation, and an Output. The difference between them is that in a regular Procedure the focus is on the Transformation language. Meanwhile, in a Data Provider, the focus is on the Output language.

For example, if the process consists of reading all customers (Input) and writing an XML file with them (Output), the Procedure is as follows:
&XmlWriter.Open(...)
&XmlWriter.WriteStartElement('Clients')
For Each
   &XmlWriter.WriteStartElement('Client')
      &XmlWriter.WriteElement('Code', CustomerId.ToString())
      &XmlWriter.WriteElement('Name', CustomerName)
   &XmlWrite.EndElement()
Endfor
&XmlWriter.EndElement()
&XmlWriter.Close()
&XmlWriter is a variable of the GeneXus XMLWriter data type.
Here is not so easy to quickly 'see' the procedure output. Indeed, it is confusingly embedded inside the code written to obtain it.
Instead, the Data Provider shows clearly the intention:
Clients
{
     Client
     {
          Code = CustomerId
          Name = CustomerName
     }
}
Then, through the ToXML method, the output could be easily converted into the equivalent XML format:
<Clients>
   <Client>
      <Code>1</Code>
      <Name>John Smith</Name>
   </Client>
   <Client>
      <Code>2</Code>
      <Name>Jennifer Lopez</Name>
   </Client>
   ...
</Clients>
The way GeneXus implements hierarchical structures is the Structured Data Type (SDT) object. You can see this example fully implemented.
As you can see, a Data Provider is easier to write and understand, so some tasks will be easier to do with Data Providers than with regular Procedures. Which are they? Those that return structured data. For example:
Writing XML files, like Web Services and RSS feeds.
Filling SDTs, like the one used to bind with User Controls, GXchart or TabbedView Web Component.
Filling the structure of BCs, that can be returned in a collection variable and then, going through it, saving in the Database.
Examples
Before going into a more formal definition, it can be helpful to present some samples:
Sample 1: Listing today's Invoices ordered by the amount
Invoices
{
  Date = today()
  Invoice Order InvoiceAmount
  Where InvoiceDate = today()
  { 
    Id = InvoiceId 
    CustomerId = CustomerId
    CustomerName = CustomerName
    Amount = InvoiceAmount
    Product
    { 
      Id = ProductId
      DetailQuantity = InvoiceDetailQuantity 
      DetailAmount = InvoiceDetailAmount 
    } 
  }
}
The output will be an SDT with today's date and a collection of items representing those invoices with InvoiceDate = today().
Sample 2: System Constants
ChartConstants
{
  ChartServer = 'http://www.gxchart.com/drawchart.asp'
  ChartParameters = '...'
}
Another example in the same area is loading the Tabs SDT needed by the TabbedView Web Component:
LoadTabs parm(&CustomerId)
Tabs
{
  Tab
  {
    Code = 'General'
    WebComponent = link(WCustomerGeneral, &CustomerId)
  }
  Tab
  {
    Code = 'Invoices'
    WebComponent = link(WCustomerInvoices, &CustomerId)
  }
}
(see here for more details).
Sample 3: RSS feed with today's Invoices
rss
{
  version = ""2.0""
  channel
  {
    title = ""Today's Invoices""
    link = link(ViewTodayInvoices)
    item where InvoiceDate = today()
    {
      title = format('Invoice %1', InvoiceId)
      link = link(ViewInvoice, InvoiceId)
      description = format('Invoice %1 for customer %2, amount %3', InvoiceId, CustomerName, InvoiceAmount)
      author = 'system'
      pubDate = today()
    }
  }
}
Now that you understand the spirit of Data Providers, take a look at:
Data Provider language
Data Provider: Input
Data Provider: Output
Using Data Providers in Other GX Objects
Expose a Data Provider as Web Service
Recursive Data Providers
And at the following examples and use cases:
Example: step by step 'CustomersProvider' Data Provider
Data Provider Use Case: TabbedView usage
Data Provider Use Case: sales invoice into accounting
Example: Data Provider Break
Data Providers go a step further in 'declaring' instead of 'programming'. The big advantage: the underlying implementation can be changed, and the Data Provider will remain valid. More on Data Providers philosophy.
Videos
Compound data types
 Loading Structured Data Types (SDTs) using Data Providers
"
83,Language,"https://wiki.genexus.com//commwiki/wiki?5309,Table+of+contents%3AData+Provider+language","The language used in Data Providers can be defined as output-based declarative language. It has three main components: Groups, Elements, and Variables. For example:
Customers    // this is a Group
{
   &StartTime = now()  // this is a Variable
   Customer  // this is a Group
   {
      Code = CustomerId    // this is an Element
      Name = CustomerName  // this is an Element
   }
}
'Customers' and 'Customer' are Groups, 'Code' and 'Name' are Elements, and '&StartTime' is a variable.
This example follows the syntax conventions of the three components of Data Providers: Groups, Subgroups, Variables and Elements.
Remember that the output will be hierarchical data, loaded in an SDT or BC that is specified in the Output property. The hierarchical structure that is obtained with the names of groups and elements must exactly match this structure."
84,Input,"https://wiki.genexus.com//commwiki/wiki?6292,Data+Provider%3A+Input","The Input of most GeneXus Objects is:
taken from parameters, and/or
embedded into the code

Parameters
The Data Provider object supports receiving parameters, but all parameters are ""IN"" parameters. Remember the output is specified independently through the Output property.

Embedded
Even though the input is usually taken from the Database, it is usually necessary to have other kinds of input data. Because a Data Provider implements an output-driven programming (that is to say, declarative), the only way to obtain information to fill hierarchical structures is through assignations:
&Element = Expression
&var = Expression
So, every 'thing' that could be considered as (part of) an expression, is a valid input. For instance: an udp (calling a Procedure as well as a Data Provider. For the latter, you can see a simple sample here, or another one with Recursive Data Providers). Keep in mind that if the returned value is a collection, the Input clause is needed to iterate inside it.
GeneXus objects have other common Input sources: web sessions and cookies.
How do we obtain a web session value corresponding to a key? By having a variable of the 'WebSession' GeneXus data type, through the ''Get'' method:
value = &webSession.Get( key )
So, it could be a Data Provider's Input, as long as '&webSession.Get( Key )' returns a value. In other words, it could be assigned to an Element or variable of the Data Provider's source.
The same can be said about the 'GetCookie' function, used to obtain a cookie's value:
value = GetCookie( CookieName )



"
85,Output,"https://wiki.genexus.com//commwiki/wiki?41037,Output+property","Scope
Objects: Data Provider
Description
The output of a Data Provider object is a hierarchical structure. The way GeneXus represents that kind of data is the Structured Data Type (SDT) object or a collection of them. Even, a Business Component or a collection of them can also be returned.
The only way to point out the Data Provider output is by setting this property (it is not possible to do it through the Parm rule). 
Completing this property is mandatory.
If you drag an SDT (or a Transaction that is Business Component) from the KB Explorer to the source of a Data Provider, the Data Provider Output property is automatically set with the name of the SDT (or BC).


Business Component as output
The GeneXus Transaction object provides also a way to represent hierarchical data, but at the database level, through a user interface (the Form). The corresponding hierarchical structure resulting from keeping only the structure (and all the logic) but not the Form is called Business Component (BC). So, a Business Component also involves an SDT, that is, a hierarchical structure that can be used in the same scenarios an SDT can be used. For this reason, the output of a Data Provider can be not only an SDT (or a collection of them) but also a BC (or a collection of them).
There is no difference if the output of the Data Provider is an SDT or a BC. The BC structure is filled inside the Data Provider source just like an SDT.
Something important to take into account is that the object that calls the Data Provider will have to work with the result returned by the Data Provider, and execute the Insert method or the InsertOrUpdate method to perform the insertion(s) into the database. 
Properties related to this property 
The following properties allow you to modify if you want to return an instance or a collection or a matrix of the type you have set in the Data Provider Output property:
- Collection property
- Collection Name property
Runtime/Design time
This property applies only at design-time."
86,Recursive Data Providers,"https://wiki.genexus.com//commwiki/wiki?4891,Recursive+Data+Providers","Data Providers can fill recursive structures, either directly or through recursive calls.

Consider an 'Employee' transaction with the following structure:
Employee
{
   EmployeeId*
   EmployeeName
   BossId subtype of EmployeeId
   BossName subtype of EmployeeName
}
Example 1
Suppose it is necessary to load an employee's information into a structure (for example to send it as a parameter to another object). First, the SDT should be defined as follows:

Note that this is a Recursive SDT. Then, a Data Provider receiving the employee will solve the problem:

Where:
Output: EmployeeSDT

Collection: False

Parm( &EmployeeId );
This is a recursive Data Provider. DPLoadEmployee is calling itself to fill the recursive member of the EmployeeSDT. For example, the XML output (DPLoadEmployee( 123 ).toXML()) would be:
<EmployeeSDT>
    <Id>123</Id>
    <Name>John Doe</Name>
    <Manager>
        <Id>99</Id>
        <Name>Mary Shelley</Name>
        <Manager>
            <Id>69</Id>
            <Name>Ernest Jackson</Name>
            <Manager></Manager>
        </Manager>
    </Manager>
<EmployeeSDT>
Example 2
Now suppose that given an employee, you have to Output all his/her subordinates (direct or indirect), as shown below:
<SubEmployees> 
   <Employee>
      <Id>99</Id>
      <Name>Mary Shelley</Name>
      <Subordinates>
         <Employee>
            <Id>123</Id>
            <Name>John Doe</Name>
            <Subordinates>
	       ...
	    </Subordinates>
         </Employee>
         <Employee>
            <Id>150</Id>
            <Name>Camile Green</Name>
            <Subordinates>
               ...
            </Subordinates>
         </Employee>
         ...
      </Subordinates>
   </Employee>
   <Employee>
      ...
   </Employee>
   ...
</SubEmployees>
This can be easily done with a Data Provider.
First, it is necessary to define the Output structure (this is done using an SDT):

Second, the Data Provider itself is:
Name:   DPLoadSubordinates
Output: SubEmployees
Rules:  parm(&BossId)
 
SubEmployees
{
   Employee
   {
      Id   = EmployeeId
      Name = EmployeeName
      Subordinates = DPLoadSubordintates( EmployeeId )
   }
}
Note that this is a recursive Data Provider (DPLoadSubordinates is calling itself).





"
87,Web Panel object,"https://wiki.genexus.com//commwiki/wiki?6916,Category%3AWeb+Panel+object","Defines a web application UI screen.
The main purpose of this GeneXus object is to define interactive queries to the database; however, it is a very flexible object that lends itself to multiple uses.
It allows end users to interactively query the database at runtime through a screen. The term ""interactively"" refers to end users being able to repeatedly enter different filter values through a Web Panel screen, and then query the data that match them. End users can also perform different actions on the queried data.

Web Panels don't allow updating the database; they only allow for queries (unless they're used in combination with Business Components).

Every Web Panel has an associated screen (Web Layout) where the attributes included will be queried/retrieved from the database and displayed (read-only). The variables included will be entry variables. 

The following classification describes the possible uses of Web Panels:
Entry Web Panel: A Web Panel whose only function is to accept values entered by the end user (this means its screen only contains variables). 

Display Web Panel: A Web Panel whose only function is to display information (this means the screen only contains attributes and can contain variables whose default behavior as entry variables has been changed, defining them as display variables and adding values explicitly). 

Mixed Web Panel: A Web Panel in which it is possible to enter values and display information (in this case, the screen contains both variables and attributes, or only variables—some with their default entry behavior and others explicitly defined as display variables with added values).
This classification is independent of GeneXus; that is, GeneXus does not classify Web Panels internally.
A Web Panel object has several sections that can be defined:
Web Layout
Defines the screen of the Web Panel, which the analyst designs by adding variables, attributes, and other controls, in order to allow end users to interact with it.


Rules
Define specific behaviors of said object to be defined. For example, specifying what parameters it receives, defining what variables you don't want to be accepted on the screen but rather used for displaying information, etc. 


Events
Web Panels use event-driven programming. This kind of programming allows you to define idle code, which is activated in response to certain actions by the end user or the system. 


Conditions
In this section, you can define conditions to be matched by the data to be retrieved (filters). There is another option to define filters locally in each Grid control included in the Web Layout.
Like most objects, it also has a section for defining variables (as usual, local to the object), the object's Help and Documentation as well as a Properties Editor that allows you to set up general aspects of the object.
Examples
1) Entry Web Panel
The following Web Panel includes variables and buttons in its Web Layout. The variables are enabled for the end user to assign values to them. This means they are input controls; in other words, they are not read-only.

Specifically, the &CountryId variable has been set of the Dynamic Combo Box Control Type; it has been set to show all the CountryName values stored in the COUNTRY table and the end user can select one. The CountryId corresponding to the CountryName selected by the end user will be kept in the &CountryId variable. After pressing the button “List Attractions by country,” the associated event will be executed invoking the PDF file containing the list of attractions in that country.
The variables &AttractionNameFrom and &AttractionNameTo allow entering a range of attraction names. After pressing the button “List Attractions by name,” the PDF list will show the attractions within the range received by parameter.
2) Display Web Panel
Considering the following Customer Transaction object structure:
Customer
{
  CustomerId*
  CustomerName
  CustomerPhoto
  CustomerAddress
  CustomerEmail
  CustomerPhone
}
The ViewCustomers Web Panel was defined including only Attributes in its Web Layout to display information. The attributes present in a Web Layout are always Read Only.

In this example, the attributes are included in a Grid control. So, the Grid Control has a Base Table. In other words, GeneXus takes into account those attributes to determine a database table to be navigated and to load its records in the Grid.
If you look at the Navigation View of this Web Panel you will see the following:

This Navigation View shows that the table being navigated is Customer. It is scanned ordered by CustomerId because it is the Customer table Primary key. You can indicate another order by setting the Grid Order property.
It is also possible to define a Display Web Panel without a Grid. You can insert attributes directly in the Web Layout and GeneXus will analyze them and will determine the base table to be navigated. In general, this kind of Web Panel receives the primary key as a parameter (using the Parm rule) to filter a specific record and show its data.
3) Mixed Web Panel
Consider the same Web Panel shown in the second example. Besides containing the Grid with attributes, it also contains variables in the Web Layout fixed part.

Variables allow end users to enter values for them. So, this Web Panel contains variables (that are editable) and attributes (that are read-only).
The variables are located in the fixed part of the Web Layout and the attributes are included inside the Grid.
The Grid navigates all the Customer table records and loads their data as rows in the Grid. To show in the grid only those records whose customer names are included in the range entered by the end user in the variables, you only have to define the Grid Conditions:
CustomerName >= &CustomerNameFrom;
CustomerName <= &CustomerNameTo;
Look at the following image that shows the Grid Conditions defined:

This is an interactive query.
Scope
Generators: Java, .NET, .NET Framework
Videos
Web panel object. First steps
"
88,Menu object,"https://wiki.genexus.com//commwiki/wiki?16321,Category%3AMenu+object","Displays a set of items the user may choose to take actions.
Description
A Menu is usually the entry point of a Native Mobile application. It displays a set of items the user may choose from, for example, it may display items such as Work With objects, Panel objects, Menus, links to web pages or actions like making a phone call or sending an email.
You can create a Menu object through the New Object dialog.
Object properties
Remarkable properties of Menu object are listed below.
Name property
	Name of the object.
Description property
	Description of the object.
Module/Folder property
Folder or Module to which the object belongs.
Object Visibility property
	Whether other Module objects can access it.
Main program property
	Enabled by default. See Native Mobile Main object properties.
Connectivity Support property
	Defines if the object will be online or offline.
Enable Data Caching property
	Specifies whether the object will use data caching or not.
Check For New Data property
	Indicates whether it uses cached data or asks the server if the data has been changed.
Once a Menu has been created it will have a tree-like interface where you can add the items you wish to be displayed on it, and adjust their properties to your needs.

Menu node properties
Selecting the 'Menu' item on the tree, there are the following properties available.
Title property
	Title for this Menu.
Background property
	Menu background image. It must be an Image object.
Header property
	Menu header image. It must be an Image object.
Class property
	Menu theme-class.
Control property
	Can be List, Tab, or Table.
Tabs Distribution property
	Only visible when Control property value is Tabs. Indicates how the Tab options will be distributed in the Tab control for the Menu. Possible values are Platform Default, Fixed Size, and Scroll. The
Fixed Size value applies when the control has few options (at most five), in that case, each of them has the same width in the Tab control. On the other hand, the Scroll value puts each option with the needed width depending on the image and caption. This option allows scrolling the tab control when the number of options exceeds the width of the screen.
	Applies only for Android, Tab control in Menu always behave as Fixed Size value for iOS applications.
Appearance group

Show Applications Bars
		Enable or disable the Application Bars.
Application Bars Class
		Application theme-class.
Items node properties
The Items are the elements that will compose the Menu (generally Work With associated with the Transaction object or Panels). To add new Items drag the object from the KB Explorer and drop it in the Items node of the Menu. Also, you can right-click on Items node following by Add Action.

Each Item has the following properties.
Name property
	Name of the option. This name will be referred to as its action on the Event tab.
Description property
	Description of the option. If its value is empty, the property name will be is used. If you want an empty description on the Menu, it is needed to add a blank space in the property.
Image property
	An icon used for the option. It must be an Image object. If the Control property for the Menu node is set to Tabs, iOS and Android require the image file format to be PNG and only its transparency will be taken into account.
Class property
	MenuItem theme-class used for the option.
Sample
Consider the following Transaction object:
Property
{
   PropertyId*
   PropertyName
   PropertyAddress
   PropertyPhoto
}
Assume that the Work With pattern was applied to it.
Then, the following Menu object is created and the WorkWithProperty object is dragged from the KB Explorer and dropped to the Items node of the Menu

The event associated with the new item is automatically defined when dragging and dropping the object:
Event 'WorkWithProperty'
    WorkWithProperty.Property.List()
EndEvent
Look at the Menu at runtime (and the objects called):

Notes
As of GeneXus 16 upgrade 2, when using Tab control for Menu options, the ActivePageChanged event, and the Menu.ActivePage property is available to be used in the object events.
In iOS, showing a Menu as Tabs only works for the main object. If the Menu is not the application's main object and it has the Control property set to Tabs, it will be shown as a List. This is to conform to Apple's Human Interface Guidelines that state that:
In general, use a tab bar to organize information at the app level. A tab bar is a good way to flatten your information hierarchy and provide access to several peer information categories or modes at once. ... A tab bar enables global navigation for your app, so it should remain visible everywhere.
See also
Several ways to show a Menu
Calling objects from Menu Events
Theme object
Videos
Conceptual model of mobile applications

"
89,Panel object,"https://wiki.genexus.com//commwiki/wiki?24829,Category%3APanel+object","Defines a UI screen, no matter whether it is for Native Mobile, Web, TV, or a Watch. It shows and/or requests data through flexible abstract Layouts. User and system actions are defined through Events.
Description
This object provides all the freedom to design the layout without pre-established structuring. The layout is empty, ready to be completed. You have to implement everything from scratch.
Through this object, you can show data to the user, ask the user for data, and make appealing and flexible layouts. It is very useful for creating more-complex user information interaction screens, creating wizards, showing messages, creating another kind of menus (different from the Menu object and more flexible), showing data obtained from other sources (e.g. Data Provider objects).
It is analogous to a Web Panel object (and to any section in a Work With pattern and Work With object empty initialized). That is to say, it implements a single screen that starts empty, with no definition, so you have the absolute freedom to put and remove what you want, and load the data from the database or anywhere else.
Sample
Suppose you need to define a Panel to ask the user for a date and invoke another Panel that shows all the appointments for that day. To do so, you have to define a variable &AppointmentDate based on the Date data type, incorporate it in the layout, and insert a button in the Layout with an associated event defined in the Events section.

This Panel does not have a Base Table, but you could design Panels with Base Table.
Grids
There is no maximum of grids to be added to a Panel (neither without a base table nor with a base table).

Here you can see a Panel that shows tweets which has been implemented from scratch by adding a grid to that panel's layout, with variables. These variables belong to an SDT that will be loaded by accessing an API, an external service from Twitter that will return the tweets.
Although there are some differences between Panels and Web Panels regarding the use of events, they are very similar.
Scope
Generators: Android, Apple, Angular
See also
Web Panel object
Work With pattern and Work With object
HowTo: Loading Data Using SDT on Panels Layouts

"
90,KB Platforms,"https://wiki.genexus.com//commwiki/wiki?24284,KB+Platforms","Platforms vary by OS, Version, Device Kind, Size, among other aspects, and are key to defining layouts that vary by those aspects. Some of the platforms are predefined with default settings, and you can customize those settings or create your own platforms too if you require it.
Platforms node in KB Explorer
The Platforms node lists all the defined platforms of a KB, and is also a shortcut to change the settings of a platform. It is located in the KB Explorer, under the Customization node.

For each platform, some properties are offered to configure several aspects:
Platform properties
Below, you will find a detailed list of the properties offered for different platforms. You can find them under Customization node > Platforms subnode in the KB Explorer:
Name
Specifies the Platform name


  OS
Specifies the Target OS for this platform. Values: All, Android, iOS, Web


  Version 
Specifies the OS Version 1


  Device Kind
Specifies the Target device kind for the platform. Values: All, Phone or Tablet, TV, Watch


  Size
Specifies the screen size and resolution. Values: All, Small, Medium, Large


  Style
Specifies the Design System or Theme


  Additional Styles property 
Specifies the Additional UI Design Systems or Themes associated with this platform


  Navigation Style property
Specifies the navigation style


  Default Layout Orientation property
Specifies the Layout orientation


  Bounds Name
Specifies the Name for the given bounds


  Minimum Shortest Bound  
Specifies the minimum size in dips of the shortest device bound  2


  Maximum Shortest Bound 
Specifies the maximum size in dips of the shortest device bound 3


  Minimum Longest Bound  
Specifies the minimum size in dips of the longest device bound  4


  Maximum Longest Bound 
Specifies the maximum size in dips of the longest device bound 5
1 Version property: Available for Android, iOS, and Web.
2 Minimum Shortest Bound property:  Only available for iOS.
3 Maximum Shortest Bound property:  Only available for iOS.
4 Minimum Longest Bound property: Available for iOS and Web.
5 Maximum Longest Bound property: Available for iOS and Web.
Add a new Platform
To create a new Platform select the Preferences tab > Patterns node > Work With subnode (you have to double-click on it to open its configuration tree).
Once there, right-click on the Platforms node and select: Add > Platform:

Creating a new Platform enables you to be more precise when choosing the layout to design.
See Also
Multiple Layouts in Panels
"
91,Multiple Layouts in Panels,"https://wiki.genexus.com//commwiki/wiki?23489,Multiple+Layouts+in+Panels","In different devices and even in the same device you may want to use different designs. For example:
In a Tablet, you may want to use one design and in a Phone, you may want to use another design.
In an Android device, you may want to use one design and a different design when using an Apple device, even though they have the same screen size.
In the same device, you may want to use one design in Portrait mode and another one in Landscape mode.
In the same device, you may want to use one design if you are editing an entity and another one if you are viewing it.
Scope
Generators: Android, Angular, Apple.
Multiple Layouts
GeneXus allows having more than one design per Panel. For this, it allows designing in each Panel different layouts that vary by Platform; that is, varying by Operating System (OS), Device Kind,  size, OS version, and orientation. When creating a Panel object, a default layout is created to be used for  Any Platform, Any Size, Any Version, and Any Orientation.

By pressing the ""Add Layout"" button, you can create new designs.


As you can see in the above images, the select the layout type option allows you to choose the platform, the device kind, etc. so that you can define the layout design for that combination.
Also, you can use the select a template layout option to initialize the new layout design with the design of a previously created layout.
When pressing the click here link, the new layout design will be created with the selected type / based on the selected template.
Then, in the bottom left corner of the Panel Layout section, you can select each layout to design it.

Layouts by Mode (in WorkWithDevices Detail)
In the Work With Devices Detail Layout, in addition to the platform, size and orientation, you can also define different layouts designs depending on the Mode (View and Edit):


See Also
Native Mobile Applications Events
KB Platforms

"
92,Data Selector object,"https://wiki.genexus.com//commwiki/wiki?5271,Category%3AData+Selector+object","Stores a set of Parameters, Conditions, Orders, and a Defined By clause, in order to invoke it from different queries, calculations, etc. and reuse the same navigation several times.
Defining Data Selectors brings the following advantages:
Saving and reusing code: You define a Data Selector once, and you can use that definition in several places in the Knowledge Base
Less maintenance: You change a Data Selector definition in one place, and it applies automatically everywhere it is used in the Knowledge Base
They facilitate new GeneXus users training: They provide code encapsulation and are easy to learn, define and use
Example

Look at the “Customer” transaction above. It contains the CustomerStatus attribute, and one of the possible values that it stores is “Active”.
Suppose that you need to query the ""active customers"" (CustomerStatus= “Active”) in many objects. For example:
a procedure of active customers, grouped by Gender
a procedure that applies a discount for active customers
a web panel that shows the total purchases of each active customer
So, it is appropriate to define a Data Selector with the filter condition and invoke it from the necessary places.
Defining Data Selectors
Once a Data Selector has been created, it basically contains:
A structure (here Parameters, Orders, Filters and Defined By clauses are defined)
Properties
Documentation
Look at the following images, which show a Data Selector named ""RetrieveOnlyUserIdRecords"" that defines the proposed filter:

Invoking Data Selectors
Once a Data Selector is defined, it can be invoked from:
For Each groups
Grid controls
Aggregate formula definitions
In Smart Devices objects
See also
Data Selectors in Grids
Data Selectors in Aggregations
Data Selectors in Data Providers
Data Selectors in For Each command
Data Selectors in Web Panels
Work With List Node
Entry Panels as Filters for a List in Smart Devices
Videos
Data Selectors


"
93,In For Each groups,"https://wiki.genexus.com//commwiki/wiki?5312,Data+Selectors+in+For+Each+command","There are two ways to use Data Selectors in For Each command:
Through the USING clause.
Through the IN operator in the Where clause.
Depending on how they are used, the attributes included in the Data Selector definition are involved or not in determining the Base Table of the For Each command.
1. 'USING' clause
Syntax
For Each [<BaseTrn1>|<BaseTrn.Level1>,...,<BaseTrnN>|<BaseTrn.LevelN>] 
    USING <DataSelectorName>([<parm1>,...,<parmN>])
      <MainCode>
EndFor
View Syntax conventions
Where:
BaseTrn1 | BaseTrn.Level1,...,BaseTrnN | BaseTrn.LevelN
      Is a Transaction or a Transaction.Level name separated by a comma.
DataSelectorName
     Is the name of the Data Selector.
parm1, …, parmN
     Are variables defined in the called object or attributes.
MainCode
     It is the list of commands.
Samples
Sample A
Suppose you have the following Transaction:
Customer
{
CustomerId*
CustomerName
CustomerImage
CustomerStatus     
}
The ""ActiveCustomers"" Data Selector definition is as follows:

This Data Selector has a condition defined in order to show the Active Customers.
Then you can define the following in the Source of the Procedure Object (or Web Panel, for example), to invoke the Data Selector:
For each Customer USING ActiveCustomers()
   print printblock1   //The printblock1 contains the attributes: CustomerId, CustomerName
EndFor
Sample B
Suppose you have the following Transaction:
Invoice
{
InvoiceId*
InvoiceNumber
InvoiceDate
}
Define a Data Selector called InvoicesByDate as follows:

The Data Selector has a date condition and orders by InvoiceDate.
You can define the following in the Events of a Web Panel (or in a Procedure, for example), to invoke the Data Selector:
For Each USING InvoicesByDate(&FromDate, &ToDate)
      &InvoiceId = InvoiceId
      &InvoideDate = InvoiceDate
EndFor
Considerations
When invoking a Data Selector through the USING clause in a For Each, the Data Selector doesn't have an associated navigation (it doesn't have a base table by itself). At specification time, the Data Selector definition is combined with the For Each definition to determine the table that will be navigated, taking into account the attributes of both definitions. In addition:
If the For Each and the Data Selector have Conditions, both are considered
If the For Each and the Data Selector have Order clause(s), the resulting Order will be a combination of them. The For Each order has priority, so in the event that GeneXus discards a Data Selector Order, a warning spc0135 will be triggered at specification time
Suppose you have the following For Each that invokes the ""ActiveCustomers"" Data Selector through the USING clause:
For Each Using ActiveCustomers()
    Where CountryName = ""Uruguay""
          ...
EndFor
This is expanded at specification time to:
For Each 
    Where CustomerStatus = ""Active""
    Where CountryName = ""Uruguay""
          ...
EndFor
Note: if you invoke the Data Selector within the For Each (above example), performance is the same as if you wrote both Where clauses within the For Each.
Navigation Report: the Data Selector is not detailed.
Suppose you have defined a For Each sentence that contains conditional orders + one unconditional order ('default' order), and it invokes a Data Selector through the USING clause. As the For Each command only accepts one 'default' order, the specification's result will be the For each with its conditional orders + Data Selector conditional orders + the For Each 'default' order (the Data Selector 'default' order will be discarded, and the navigation report will show a spc0135 warning).
2. 'IN' Operator in the Where clause
Syntax
For Each [<BaseTrn1>|<BaseTrn.Level1>,...,<BaseTrnN>|<BaseTrn.LevelN>] 
     Where [not] <attribute> IN <DataSelectorName>([<parm1>,...,<parmN>, …])
    <MainCode>
EndFor
View Syntax conventions
Where:
BaseTrn1 | BaseTrn.Level1,...,BaseTrnN | BaseTrn.LevelN
     Same as Base Transaction clause in For Each command.
Attribute
     Is The name of the attribute that can belong or not to the extended table of the Data Selector base table.
DataSelectorName
     Is the name of the Data Selector.
parm1, …, parmN
     Are variables defined in the called object or attributes.
MainCode
     It is the list of commands.
Samples
For Each
    Where CustomerId IN InvoicesByDate(&FromDate,&ToDate)
          ...
Endfor
Considerations
When invoking a Data Selector through the IN operator in the For Each Where clause, the Data Selector has a base table by itself. This means that a SELECT sentence will be generated for the Data Selector definition, which will be a different and independent SELECT from the SELECT sentence that will be generated in relation to the For Each.
Up to GeneXus 15 Upgrade 5, the attribute that precedes the IN operator must belong to the extended table of the Data Selector base table. In the above example, CustomerId belongs to the extended table of INVOICE, which is the ""InvoicesByDate"" Data Selector base table. Since GeneXus 15 Upgrade 6 the attribute associated to the IN operator does not necessarily need to belong to the extended table. The following specification is valid where there is no relationship between tables Customer and Provider.
For Each Where CustomerId In ProviderIds()
    ...
EndFor
ProviderIds Data Selector specification is as follows:
Defined by: ProviderId
Notice the usage of the Defined by clause. The resulting SQL statement is similar to the following, where there is no relationship between tables Power and User.
SELECT.... FROM [Customer] WITH
WHERE [CustomerId] IN (SELECT [ProviderId] FROM [Provider])
The Data Selector query will return a collection of values corresponding to the same definition as the attribute which precedes the IN operator. In the above example, the Data Selector returns “a customers list” with invoices in the given range.
So, the For Each base table is determined by taking into account only the For Each attributes (Data Selector attributes are not considered). The For Each will navigate its base table and extended table, filtering the records which contain a customer of the customers list returned by the Data Selector.
In other words, in the above example, the Data Selector will return what you need as long as the attribute to the left belongs to the extended table of the Data Selector base table. The internal mechanism of the extraction operation is not important; what's important is that you can declare a Data Selector and it can be called by any other object.
Navigation Report: the Data Selector is not detailed.
Some doubts may arise in relation to the order displayed in the Navigation Report, as the order specified in the Data Selector is InvoiceDate and the order detailed in the Navigation Report is CustomerId. Actually, the latter corresponds to the order of the For Each command. The Data Selector, whose navigation is not detailed by GeneXus, accesses through InvoiceDate.
Advanced notes
The Data Selector's navigation will be generated as a subselect of the For Each select. So, if the Data Selector has its own conditions, they must be evaluated in the server by the DMBS. Taking this into account, the following error/warnings could appear at specification time:
spc0053 Conditional constraint %1 cannot be generated in group starting at line n. Changed to standard constraint.
If the Data Selector has a conditional constraint, it will be automatically changed to a standard constraint.
spc0144 Condition %1 found in DataSelector %2 cannot be evaluated in server.
There are still some functions that cannot be evaluated in the server.
Compound Keys considerations
The IN Operator takes into account the attribute preceding the IN clause; if you want to filter using a compound key you will need to create a new redundant formula attribute with the concatenation needed. Using the above example, suppose you want to add multi-tenant support; a possible design is to add a TenantId* (key composition) attribute as part of all tables. To use the In operation, you will need to create a TenantIdCustomerId redundant attribute to do the filter.
For Each
    Where TenantIdCustomerId IN InvoicesByDate(&FromDate,&ToDate)
          ...
Endfor
See Also
Data Selectors in Grids
Data Selectors in Aggregations
Data Selectors in Data Providers
Data Selectors in Web Panels
Work With List Node
Entry Panels as Filters for a List in Smart Devices
Videos
Data Selectors

"
94,In Grids,"https://wiki.genexus.com//commwiki/wiki?5386,Data+Selectors+in+Grids","A Grid control or Free Style Grid control can have a Data Selector object associated through its ""DataSelector = nameDataSelector"" property (see Data Selector property). In the following image, look at the structure of the DSExampleInGrid Data Selector:

Note below that the grid contained in the Web Panel object has the previous Data Selector assigned in its Data Selector property:
The behavior is just like having a For Each with a USING clause. This means that the Data Selector doesn't have an associated navigation (it doesn't have a base table by itself). Therefore, at specification time, the Data Selector definition is combined with the Grid definition to determine the table that will be navigated, taking into account the attributes of both definitions:
If the Grid and the Data Selector have Conditions, both are considered
If the Grid and the Data Selector have Order clause(s), the resulting Order will be a combination of them. The Grid order has priority, so in the event that GeneXus discards a Data Selector Order, a warning spc0135 will be triggered at specification time
Thus, in the example shown, the grid will be loaded with all the Airline records that fulfill the grid conditions and the Data Selector conditions. The order with which the data will be retrieved will result from a combination of the specified orders in both definitions:

Notes
If parameters need to be provided to the DS, list them in the Parameters property and separate them with commas.
Data Selector does not work in a Transaction's Grid.
See also
Data Selectors in Aggregations
Data Selectors in Data Providers
Data Selectors in For Each command
Data Selectors in Web Panels
Work With List Node
Entry Panels as Filters for a List in Smart Devices
Videos
Data Selectors


"
95,In Formulas,"https://wiki.genexus.com//commwiki/wiki?5432,Data+Selectors+in+Aggregations","It is possible to use Data Selector objects in Aggregate Formulas.
Syntax
Data Selectors can be referenced in Aggregate formulas, with the USING clause according to the following grammar:
<AggFormulaName> (<Expression>, [<AggregationCondition>], [<DefaultValue>])
View Syntax conventions
Where:
AggFormulaName
     Could be one of the following: Find, Max, Min, Sum, Count, or Average.
Expression
     Is an expression to be found, maximized, minimized, summed, or averaged. It can be an attribute (stored or formula), or an expression that involves attributes, variables, and constants.
AggregationCondition 
     Is composed of [<Condition>]  [USING <DataSelector> '(' <Parameters...> ')']
DefaultValue
     Is the returned value when no records match the AggregateCondition. It is a constant and it is optional.
Notes
For Count formulas, the first parameter can't be an expression. On the other hand, it must be an attribute.
For Sum and Count formulas, the result of evaluating the expression must be a numeric value.
When using a Data Selector (USING clause), the use of Procedures is not suported in the formula definition. Otherwise, the spc0026 will be detailed and the formula cannot be solved.
User variables can only be used in inline formulas.
Samples
Consider the following Transaction objects:
Country
{
  CountryId*
  CountyName
}

Customer
{
  CustomerId*
  CustomerName
  CustomerStatus
  CountryId
  CountyName
}
Consider the ""ActiveCustomers"" Data Selector definition as follows:

1) To count the total number of active customers you can define inside an event, source, etc. the following code:
&NumberActiveCustomers = Count(CustomerName, USING ActiveCustomers())
2) To count the number of active customers per country you can define the following code:
For Each Country
   &NumberActiveCustomers = Count(CustomerName, USING ActiveCustomers())
EndFor
Something important to know is that the CustomerName attribute -the first parameter in the count formula- is not taken into account by GeneXus to determine the For Each Base Table. The CustomerName attribute belongs to the Formula definition.
The For Each base table is COUNTRY (because Country is mentioned as Base Transaction).
The table navigated by the Formula (in which the calculation is made) is CUSTOMER (because the attributes mentioned in the formula and in the Data Selector definitions belong to the CUSTOMER table).
Finally, the two tables that are navigated, COUNTRY and CUSTOMER, have a common attribute: CountryId. So, for each navigated country (by the For Each command), the Aggregate Formula defined inside the For Each (inline) considers only the active customers that belong to the country being navigated in the For Each query, at the moment of triggering the formula.
See Also
Data Selectors in Grids
Data Selectors in Data Providers
Data Selectors in For Each command
Data Selectors in Web Panels
Work With List Node
Entry Panels as Filters for a List in Smart Devices
Videos
Data Selectors

"
96,In Data Providers,"https://wiki.genexus.com//commwiki/wiki?6501,Data+Selectors+in+Data+Providers","A Data Selector can be used in a Data Provider group in exactly the same way as in a For Each command.
Some examples already seen in 'Data Selectors in For each Groups' show this.
If you have the following Data Selector:

From a Data Provider you can return the list of customers having an invoice in a given range (for example, taken from parameters):
1) 'USING' clause
Clients
{
     Client USING InvoicesByDate( &FromDate, &ToDate )
     {
        Code = CustomerId
        Name = CustomerName
     }
}
When invoking a Data Selector through the ""USING"" clause in a group (same as a For each), the Data Selector doesn't have an associated navigation (it doesn't have a base table by itself). At specification time, the Data Selector definition is combined with the Group definition to determine the table that will be navigated, taking into account the attributes of both definitions. So, the base table associated with the 'Client' group will be INVOICE.
2) 'IN' operator in the Where clause
Clients
{
    Client
    where CustomerName IN InvoicesByDate( &FromDate, &ToDate )
    {
       Code = CustomerId
       Name = CustomerName
    }
}
The Data Selector query will return a collection of values corresponding to the same definition as the attribute which precedes the IN operator. In the above example, the Data Selector returns 'a customer list' with invoices in the given range.
For further information, see Data Selectors in For Each command
See also
Data Selectors in Grids
Data Selectors in Aggregations
Data Selectors in Web Panels
Work With List Node
Entry Panels as Filters for a List in Smart Devices
Videos
Data Selectors


"
97,GeneXus Controls,"https://wiki.genexus.com//commwiki/wiki?5925,Category%3AGeneXus+Controls","Controls offer all the necessary elements to develop not only the Web interface, but also the application itself when a visual interface has to be created. They are used to populate other GeneXus objects such as Web Panels and Transactions, thus enhancing the usability of the end-user interface. In this way, even though Web Controls such as Image or Table play different roles, they are integrated to give the Web Panel the necessary functionality.
In addition, there is another category of Controls known as User Controls. These controls, which might be developed by Artech or by Community users, can be integrated into GeneXus. Thus, there are two classes of Controls: Common Controls and User Controls.

The above picture shows the Toolbox, which is divided into two sections: the upper side is for Standard Controls and the lower side is for User Controls. When no User Controls are installed, this area is not displayed.









"
98,Standard Controls,"https://wiki.genexus.com//commwiki/wiki?5928,Category%3ACommon+Controls","GeneXus provides a set of standard controls that allow not only the creation of the user interface but also of the application itself. These controls, which are applicable to Web Panel objects and Transaction objects, are located in each object's Toolbox.
The following figure shows a web form and the Toolbox:

To insert a control in the web form, just drag it from the Toolbox to the web form.
Standard Controls Catalog
Controls
	
Attribute/Variable. Inserts both attributes and variables in the form from a selection dialog box.
Button. Allows inserting a button in the form. The button may be associated with a previously defined event or you may wish to define a new event for the button.
Embedded Page. Allows the inclusion of external information to display the contents of any URL in Web objects generated with GeneXus.
Error Viewer. Where messages are displayed.
Horizontal Rule. Inserts a cosmetic line in the web form.
HyperLink. Links in the object’s Web form. Before adding a link you will be able to configure it.
Image. Pictures in the object’s Web Form to show different images from the Knowledge Base Image repository.
Text Block. Text blocks in the object’s Web form.
Web Component. Web Panels that have a property indicating that they are components.
Table. Tables in the form where other objects, such as images, text, etc., are added inside rows and columns.


Containers
	
Flex
Free Style Grid. Inserts a grid to put attributes, variables, images, etc. 
Grid. Inserts a grid that shows multiple records from attributes and variables.
Group. Inserts a container to deploy other objects separately and titled.
Html
Responsive Table
Section. The area where other objects are added such as images, text, etc.
Tab
Table control


Action Groups
	
New Action Group


Miscellaneous
	
AnimationView
BasicTab 
Tab
In addition to the above mentioned controls, the following standard controls are also available in the toolbox under their relevant category.
Extended Controls
	
DashboardViewer 
FBHoverPanel
FileUpload
GXMediaPlayer
GXprogressIndicator
Scheduler Control
HistoryManager
Image Gallery
QueryViewer
Treeview


GXGoogle Visualization Library
	
More Information...


Gauges
	
GoogleGauge
When GXflow is used,
GXflow Entry Point. Used to embed any of the GXflow components within the generated applications.

"
99,Extended Controls,"https://wiki.genexus.com//commwiki/wiki?5273,Category%3AWhat+is+a+User+Control%3F","In addition to using the standard GeneXus controls, GeneXus supports the use of custom controls.
These controls are called User Controls (also known as Extended Controls) and allow you to create applications with rich, user-friendly interfaces, for example, by adding menus, maps, charts, calendars, diagrams, and many other resources.
See Also
User Control object
Web User Controls
User Controls for Native Mobile applications

"
100,Reporting in GeneXus,"https://wiki.genexus.com//commwiki/wiki?25314,Table+of+contents%3AReporting+in+GeneXus","When creating enterprise applications, it is always needed to have the best reports in order to make the best decisions. To accomplish that, GeneXus provides you with a variety of possible solutions.
Static reports
When you need to define small reports, like invoices or daily reports, this is the easiest way to do it. By creating a Procedure object with visual output, you can define a PDF Report.

Even though in each Procedure you define all the logic and the layout that makes up that report, you can decide to 'turn-on' the Customizable Layout property to allow the end-users to customize the layouts by using a simple tool. (Learn more about this possibility).
Visual and dynamic reports
This is the type of report to use when you need to group the information by some specific characteristic, to get some visual perspective. Using the Query object and the QueryViewer control you can create more dynamic and visual reports, which allows you to directly manipulate the reports, leading you to a better comprehension of the information. For instance, if you are trying to make decisions about your sales department you will need to have the information in some visual way that you can make the best choice for your company.

Business Dashboards with Visual and dynamic reports
Dashboards provide at-a-glance views of KPIs (key performance indicators) relevant to a particular objective or business process. Often, the ""dashboard"" is displayed on a web page that is linked to a database which allows the report to be regularly updated. More information at Dashboard object

End-User reports
Increasingly over time users, who may not have programming skills, need to gain access to the business data on our company. GXquery 4.0, the GeneXus reporting tool, allows us to view and analyze our business data with a practical “drag & drop” system of filters and variables with which you will be able to obtain the data we need in order to make your best decisions. For more information see http://www.gxquery.com.
"
101,Language object,"https://wiki.genexus.com//commwiki/wiki?7258,Category%3ALanguage+object","Localizes your application into a certain language.
Description
Every Knowledge Base automatically contains some predefined Language objects (you can create a Language object, too) that can be referenced later for translation.
To be able to translate your application, you must first select one of the predefined Language objects (or create a new one). See GeneXus Application Localization, for more information.
A Language object contains a list with predefined texts plus other texts to be translated (for example all the strings that appear in your GeneXus Knowledge Base like attribute descriptions, strings as literals included in sources, inside Msg and Error rules, etc.). In other words, all translatable text appears in the list so that you can complete their corresponding translations for the respective language.
Additionally, this object has some Properties that you may set. They will be taken into account like the date format for that language.
Also, has a Documentation section so that you can describe information about the Language you are creating.
See also
GeneXus objects
"
102,Object Documentation,"https://wiki.genexus.com//commwiki/wiki?6685,Object+Documentation","Most GeneXus objects have a section to write documentation. All the documentation sources inside the Knowledge Base make up a wiki-like documentation system.
The Documentation Editor is a WYSIWYG editor that can be accessed at the Object level, through the 'Documentation' object's selector, as shown in the following Transaction:



"
103,Object Help,"https://wiki.genexus.com//commwiki/wiki?12512,Object+Help","This section of each GeneXus object allows you to describe the help text the end-users will be able to see at runtime.
You can access this by selecting the Help tab of each GeneXus object.









"
104,Knowledge Base Documentation,"https://wiki.genexus.com//commwiki/wiki?5275,Category%3AKnowledge+Base+Documentation","Application documentation is an important part of your Knowledge Base. Development documents range from application requirements to developer-to-developer notes, to-do lists, etc.
GeneXus provides a Wiki-style Documentation editor and repository. Wiki-style documentation has been adopted and is used by the IT community worldwide. Documents are edited with an (almost) WYSIWYG editor.
By default, each Knowledge Base contains a Main document to describe there the general and main documentation about the KB. You can find the Main document in the KB Explorer under the ""Documentation"" node.
You can include links to other objects' documentation, attributes, etc.
In the following example:

A link to the Transaction called Attraction has been added.
To include a link, you have to type a pair of square brackets in the Edit section. That will display all the possibilities to select the one you need. For example, select ""Transaction"":

All the Transactions available in your KB will be displayed:

Select Attraction to add a link to that Transaction.
In the Edit Tab, you will see it as follows:

Now, select the Browse Tab.
If you click on the link you have just included:

The Document object associated with the Attraction Transaction Documentation will be opened (it is equivalent to the Attraction Transaction Documentation tab).

If you click on the link titled ""Open Transaction.Attraction"" it will be opened.
Files can also be stored in the Documentation of your Knowledge Base.

As you can see in the image above, the files ""Sales Department.doc"" and ""Administrative Department.doc"" have been added to the Knowledge Base Documentation. The way to add them is the same as the one explained before.
Documentation included in a GeneXus Knowledge Base may be useful for people who do not have GeneXus but have access to a Wiki-style website. End users, people who specialize in customizing software after installation, and programmers who do not have the Knowledge Base at hand are just a few examples of the people who may find it useful.
GeneXus lets you easily publish your KB documentation on a Wiki-style website, making it accessible to everyone inside and outside your organization. See Synchronize Documentation.
See Also
Object Documentation

"
105,File object,"https://wiki.genexus.com//commwiki/wiki?5852,Category%3AFile+object","Stores a file of any format inside the Knowledge Base.
GeneXus supports storing files of any format inside your Knowledge Base. To do so, you have to create a new File object for each file you want to include inside your Knowledge Base.
The main objective is to contain all the project knowledge within your Knowledge Base while simplifying associated management tasks. In other words, Knowledge Bases are used as common repositories, and project management is simplified.
Observe the following image that shows where to work with files:

File object creation
To create a File object click on the New... button shown above. Another way to create a File object is by selecting from the main GeneXus Menu: File > New > Object.
In both cases, the New object dialog will be displayed, but if you use the New... button you have the advantage of having the File object type preselected:

Actions on Files
When right-clicking on a File the following context menu is displayed:

Edit
Opens the File in the editor for that type of file (defined in the operating system). With that editor, the file can be modified and when saving, the file is updated in the Knowledge Base.
Update
The following dialog is opened so that you can upload again the file associated with this File object and/or update its Module:

Save as...
Allows you to save the File on a path external to the Knowledge Base.
Open
Opens the file Documentation page.
The below image shows what you will see when selecting Open (or double click) for the JavaModule_jar file:

The Preview tab offers the actions described above:
Save ""File"" as...
Update ""File""
The Edit tab allows you to write/edit the File Documentation and the other tabs show the File History and Backlinks, respectively.
Files Properties
They help you define the File's behavior in relation to the following items:
Name property
Description property
Extract for Java Generator property
	> Java Generator Extraction Directory property
Extract for .NET Framework Generator property
	> .NET Framework Generator Extraction Directory property
Extract for .NET Generator property 
	> .NET Generator Extraction Directory property 
Extract for iOS Generator property
	> iOS Generator Extraction Directory property
Extract for Android Generator property
	> Android Generator Extraction Directory property
Module property


"
106,Reorganization,"https://wiki.genexus.com//commwiki/wiki?5288,Category%3AReorganization","Reorganization is part of the build process. It includes generation, compilation and execution of the reorganization programs in charge of creating the database (if needed and possible) and making changes in the database schema (i.e. creating / changing / dropping Tables, Views, Functions, Indices, and Constraints) and transforming the related data.
Features
Executable reorganization programs are generated compiled and executed
A Reorganization script containing the SQL of the reorganization is generated
Users can define Pre/Post Reorganization scripts
Reorganization programs
	
run in multiple threads
can count records to be transformed
verify schema as the first step in order to avoid failures
verify DBMS version in order to avoid failures
can resume after failure
For more information see Features of Reorganizations.









"
107,Build All/Rebuild All,"https://wiki.genexus.com//commwiki/wiki?5691,Build+All%2FRebuild+All","Build and Rebuild All options are used when you do not know the exact impact of the changes and need to have everything brought up to date. The Build All option does what needs to be done, while the Rebuild All option strengthens throughout.
Rebuild All usually takes longer than Build All. Both build options include the following steps:
Steps
Comments


Save any unsaved objects
This step stops on errors


Reorganize the database if necessary
Reorganize the database if necessary


Specify only objects that have changed (Build) or force the specification of all objects (Rebuild)
This step does not stop on errors


Generate
This step does not stop on errors


Compile all Main Object
This step does not stop on errors


Compile the Developer Menu
This step does not stop on errors


Deploy

Note: In .NET, the Compile Developer Menu step is not performed if the model property Generate developer menu makefile property is set to No.
See also
Build/Rebuild/Run
Build/Run With This Only
Run Without Building
"
108,Build/Rebuild/Run,"https://wiki.genexus.com//commwiki/wiki?5692,Build%2FRebuild%2FRun","These are the most frequently used build options. They work with a selected Main Object, which can either be the Startup Object or the Main object pointed to with the mouse. The typical scenario is one where you have a Main object set as the Startup Object, you change some objects and then press F5 (assigned by default to the Run command) to test the changes.
These options include the following steps:
Steps
Comments


Save any unsaved objects
The step stops on errors


Reorganize the database if necessary
The step stops on errors


Specify only objects that have changed (Build) or force the specification of all objects (Rebuild) belonging to the selected Main object call tree (*).
			Consider also objects references in the properties of KB Version (except Startup Object), Environment and Generator, with their call tree.
The step stops on errors


Generate
The step does not stop on errors


Compile the selected Main object
The step stops on errors


Deploy
The step stops on errors


Execute the selected Main object (Run)
(*)The call tree of a Main object is ""cut"" on every other Main object found unless the Call tree for build option is set to full.
See also
Build All/Rebuild All
Build/Run With This Only
Run Without Building
Videos
Build process


"
109,Build/Run With This Only,"https://wiki.genexus.com//commwiki/wiki?5693,Build%2FRun+With+This+Only","The Build/Run With This Only option is intended to build and run the Startup Object, ignoring any changes in objects other than the one selected. Say, for example, that the Startup Object is set to a Main Object named MyMain and changes have been done to programs PgmA, PgmB and PgmC, all belonging to MyMain call tree. Executing Build With This Only on PgmB causes MyMain to be rebuilt with changes to PgmB but ignoring changes to PgmA and PgmC.

Since GeneXus does not check for dependencies, these options are a fast method for testing single object changes. However, they should be used carefully as they may lead you to get confused looking for changes that were not built in the running application.

These options include the following steps:
Steps
Comments


Save any unsaved objects
The step stops on errors.


Reorganize the database if necessary
 The step stops on errors.


Specify the selected object only
Note that if other objects in the Startup Object called tree have changed, they are not specified or generated. The step stops on errors.


Generate the selected object only
The step does not stop on errors.


Compile the Startup Object
The step stops on errors.


Deploy
The step stops on errors.


Execute the Startup Object (Run)

Note: if a 'Build/Run With This Only' task is performed on SD objects, such as: Work With pattern and Work With object or Panel object, and a SD object is set as Startup Object, then it will be compiled and executed. Otherwise, If there is not any SD object set as Startup Object, the SD developer menu will be compiled/executed (KBN).
See also
Build All/Rebuild All
Build/Rebuild/Run
Run Without Building








"
110,Run Without Building,"https://wiki.genexus.com//commwiki/wiki?20689,Run+Without+Building","The Run Without Building option is intended to quickly run the selected Main Object or Startup Object (Ctrl-F5). There is no build, reorganization, or compilation; objects are only run. The idea is to run the selected object as it was when it was last built or run, ignoring any changes in the Knowledge Base.

This option performs the following steps:
Steps
Comments


Saves any unsaved objects in the workspace
This step stops on errors


Does _NOT_ reorganize the database even if it is necessary
 


Does _NOT_ specify any object
 


Does _NOT_ generate
 


Does _NOT_ compile anything
 


Executes the selected (explicit or implied) main object
Note
If the selected (explicit or implied) object was never run/built before, the execution will fail.
Availability
This option is available as of GeneXus X Evolution 3.
See also
Build All/Rebuild All
Build/Rebuild/Run
Build/Run With This Only










"
111,Set as Startup object,"https://wiki.genexus.com//commwiki/wiki?5394,Setting+an+Object+as+Startup+Object","There are two ways to set a Main Object as the Startup Object. To do so, you can:
1) Right-click on the desired object to open the context menu and select the Set As Startup Object option:

2) Go to the Preferences window and set the Startup Object property at the environment level.

Select the object you want to start running when F5 is pressed.
Note:  If you select an object that is not Main yet, GeneXus will automatically set its Main Object property to True.
See Also
Startup Object
Unsetting a Startup Object
"
112,Create Database Tables,"https://wiki.genexus.com//commwiki/wiki?7158,Create+Database+Tables","Provides an Impact Analysis Report. If the user confirms the reorganization, it generates the creation programs for the database and automatically executes them, thus creating the empty structure of the database, based on the Environment properties set in the Preferences panel from the Knowledge Base Navigator.
See also
Impact Analysis
Database Creation Report
Environments







"
113,Impact Database Tables,"https://wiki.genexus.com//commwiki/wiki?11088,Impact+Database+Tables","Performs an Impact Analysis of the current environment. An Impact Analysis Report will be displayed. This option is available under Build>Impact Database Tables.





"
114,Data View object,"https://wiki.genexus.com//commwiki/wiki?1914,Category%3AData+View+object","Defines all the information related to an external table to access it like any other table created by GeneXus.
As you all know, upon defining Transaction objects, tables are created in the database that is associated with an Environment. In some cases, you may need to work with existing tables that are not included in our data model, and which are called ""external tables."" They may belong to another model or version, or they may not be created by GeneXus.
Even though GeneXus cannot reorganize these tables, it can query them and make additions, deletions, and changes.
There are two ways to work with an external table: with an associated Transaction to make additions, deletions, and changes to this table, or without an associated Transaction. In this case, these operations can only be made through Procedure objects, and not with the usual commands but with others. The most common reasons for which Data Views are defined without an associated Transaction are when it's necessary to access an external table that has no indexes, or when it's necessary to access external tables, only once, just to define load processes (that is, batch processes that run through external tables and load tables of the Environment). Clearly, in these cases, it's not necessary to have interactive access to the external tables, but only through batch load processes; and lastly, another reason to do so is when you don't need this file to participate in the data model normalization.
Note
Data Views do not necessarily handle a table that belongs to a database; even though it happens most of the time, it can also be a text file or another type of file.
"
115,Database Reverse Engineering Wizard,"https://wiki.genexus.com//commwiki/wiki?6627,Database+Reverse+Engineering+Wizard","As you may already know, GeneXus allows you to apply a Database Reverse Engineering process, making your GeneXus application able to access data stores defined in other databases.
But how and where do you define this process?  By using the Database Reverse Engineering tool (DBRET).
In order to start this tool, follow the steps shown below:

Database Reverse Engineering Wizard: Step by Step
The Database Reverse Engineering process is completely defined by a three step wizard.  Let's go through those steps with a simple example.
Suppose you have an Agency KB (Airlines, Flights, etc.), and you want your application to access some tables (Customers and Countries) in another database. This database has the following tables:

1. Start Options
Once you have selected the Database Reverse Engineering option (see image above), you will reach the first step window, where all the necessary information to connect to the external database is requested.
In this dialog, all connection information to access the DBMS must be filled out, such as DBMS, connection method, database name, user and password.

Once this step is completed, all information about tables, indexes and relationships between tables is retrieved from the DBMS and saved in a metadata file.
2. Database Objects Selection
In this step you must select the tables you want to consolidate in this instance.
Use the ""Add Related"" button to automatically add all referenced tables (N-1 relations) to those already selected.
The ""Save Selection"" button enables you to save all selected tables to be easily retrieved in a further execution through the ""Load Selection"" button.

Following the example, if you select the Customer table and then press the Add Related button, you will be selecting Customer table and Country table, as it is shown in the image below:

After this step, the Reverse Engineering Process itself takes place, where the DBRET (Database Reverse Engineering tool)  evaluates all relationships between selected tables and defines the necessary GeneXus objects.
3. Reverse Engineering Report
In this step you will see three tags:
Report
Settings
Rules
Report
This report shows all defined objects created during the reverse engineering process and, if it finds any problems, the corresponding warning will be displayed.
These are some special warnings that could appear:
""<Attribute> is a FK to <Table> but it's not selected."" In this case there is an option -Add Table- to select this table and automatically reprocess the objects.
""The table doesn't have a primary key."" When the external table doesn't have a primary key, the DBRET creates a Data View but not the Transaction. If you want to create it anyway, select some table's attributes as a primary key by means of the
	 ""Choose Primary Key"" link.
""The attribute <Attribute> is auto number and was chosen as primary key."" This warning appears when the table does not have a primary key but contains an auto numbered attribute.
""The type <data_type> is not supported."" This message is triggered when the table contains an attribute with a data type that cannot be automatically matched with GeneXus ones. Use the ""Change Type"" option to select one of the GeneXus data types that adjusts best.
You can change some settings or define new rules in this step before finishing (reprocessing could be performed).
Now analyze the Settings and Rules options:
Settings
As you may see in the image below, the group of settings is:

Generate Transactions:

True:  A Transaction will be generated with the structure of each table to be imported.
False: Only Data View will be consolidated.


Identify Multilevel Transactions:

False: By default each table to be imported will define a Transaction and different Data View. The generated transactions will then be of only one level.
True: Certain subordination patterns are looked for to define transactions of more than one level. For example, if there is a table for OrderSalesHeader and another for OrderSalesLines, only one Transaction will be created with the two levels.


Generate Schema: When this option is True, the table schema information is stored in the data view schema property.
Naming Rule:

Prefix only when needed:  Based on the referential integrity definition in the database, the tool automatically prefixes those attributes that need to be changed to avoid conflict and preserve the tables relations based on URA. This is the default option.
Prefix always: Always prefixes attributes with the table name and defines the corresponding subtypes groups to preserve tables relationships.
Same name-same thing: This option applies to databases created with GeneXus or others based on URA definition. If two tables have the same attribute but no referential integrity control is defined between them, they will be considered as related tables.


Names separator:  If an attribute needs to be prefixed with the table name, this separator will be used.
Datastore: By default, all Data Views will belong to the default data store. With this property you can choose another data store or define a new one.
Folder: Specify the folder name where the new objects will be consolidating in the GeneXus KB.
Use Database description:

True:  The attributes description will be loaded from the database to set the ""Description Attribute"" property.
False: The attribute's description will be the same as the attribute's name.


Generate Views as Transactions:  Activating this property the user will be able to select a ""key"" attribute for the View in order to create a Transaction object associated with it.
Backup model before consolidate:  If it is activated, a model backup is created before the consolidation takes place.
Maximum length of table prefix1: In some cases DBRET could prefix the attributes with their table's name (see Naming Rule above). With this property you can set the maximum length to be considered for the prefix. (Default: 200)
Apply replace rules to attributes prefix1: True | False (default: False). In some cases DBRET could prefix the attributes with their table's name (see Naming Rule above). With this property you can change the scope of 'Raplace Rules' to be applied after the attributes were prefixed (True) and not before (False).
	Use this property with caution, as the name of the renamed attribute might match to an existing one ( DBRET only controls the uniqueness of the name when it applies the prefix).
Note: 1 These properties are available since GeneXus 15 Upgrade 5.
Rules
There are four types of rules:
Rename
Replace
Change Type
Add Relation
For the first three rules you have to specify the old information, the new information and the scope.

Once the rule is defined, you have to press the ""Add Rule"" button to add it to the rules list. The rules will be automatically applied when you back to the Report tab dialog.
Rename:  Rename everything referred to a Table, Attribute or Index ""Name"" with the ""New name."" The rule will be applied only for the ""Object type"" scope. If the Table Name scope is specified, the rule only applies to this table.
Replace:  Replace all the occurrences of the string ""To replace"" with ""Replace with"" in the names of ""Object type"" scope. If the ""Table name"" parameter is specified, the rule only applies to this table. Besides, if the ""Object Name"" parameter is specified, the rule only applies to this table/index or table/attribute.  If the property 'Apply replace rules to attributes prefix' is True, then this rules applies for those prefix.
Change Type: This rule allows changing the attribute data type. With the ""Table name"" and ""Attribute name"" parameters you specify the scope of the rule.
Add Relation:  Use this rule to establish a relationship between two tables that DBRET could not determine. This information will be taken to create the Knowledge Base model (it does not affect the real database).
In the example, you want to rename any ""Customer"" sequence as ""FlightCustomer."" So, define the corresponding Rename rule, as you may see:

Save / Load Rules:  Use the Save and Load button to backup or retrieve previously saved rules.
And that's all!! You've reached the end of the Database Reverse Engineering Wizard. Press the Finish button. What happened afterwards in the example? Look and compare both Folder View images below.
In the first one, you can see the original objects in the Agency KB.  In the other one you see the same Agency KB but with some more GeneXus objects automatically created to represent the corresponding schema. Note that as a result of the Rename rule applied, there are no ""Customer"" objects,  but ""FlightCustomer"" objects:
FlightCustomer Transaction
Country Transaction
FlightCustomer Data View
Country Data View
Country table
FlightCustomer table
See also
Reverse Engineering Process
Reverse Engineering Checkings when executed integrated to GeneXus



"
116,External classes,"https://wiki.genexus.com//commwiki/wiki?5669,Category%3AExternal+object","Defines the programming interface for an external resource from the Knowledge Base as if it were just another object.
The external resources can be native classes of the language, assemblies (.dll) if they are developed in .NET, or classes (.class) in the case of Java. Also, they can be Enterprise Java Beans (EJB), Stored Procedures (SP), or Web Services (WS).
Creation
You can create an EO manually from the New Object dialog, indicating each property/method, or you can use a Wizard/Inspector to make your work easier.
The properties and/or Wizards that you can use to create the EOs vary based on the type of EO. The types of EOs are the following:
Stored Procedure
Native Object (assemblies and/or classes)
WSDL (Web Service)
Java Session Beans
To create an EO through Wizards/Inspectors, under the Tools/Application Integration menu you have the following options:
.Net Assembly Import Wizard
Java Class Import Wizard
WSDL Import Wizard
Use
Once an EO has been defined based on the properties related to the external resource you wish to use, the EO will be available just like any other type of data in the Knowledge Base, and you can use it from any of the objects you have. This is done in the same way as with any extended data type: by defining a variable of that type and then calling the methods and/or setting the properties you need.
Note
External objects aren't intended for the following cases:
To interact with external Data (data on tables maintained by other applications), use Data Views. That is, create a Data View object or let the Database Reverse Engineering Tool do the work for you.
To interact with external Javascript, take a look at External Objects for Javascript.
"
117,Rest web services in GeneXus,"https://wiki.genexus.com//commwiki/wiki?28213,Table+of+contents%3ARest+web+services+in+GeneXus","GeneXus has the ability to automatically create REST Web Services using API objects (and also, for compatibility reasons, it is possible to configure Transactions that are Business Component (BCs) as Rest Web Services, configure Data Providers as Rest Web Services and configure Procedures as Rest Web Services).
By setting the necessary configuration, the data that encapsulates the API, Business Component, Data Provider or Procedure may be accessed through the web as a REST service using the HTTP protocol.
A Rest application requires a different approach than a remote procedure-based application.
In Rest, the focus is placed on a wide range of resources; for instance, a Rest application could define resources such as products, clients, purchase orders, etc.
So, the process to design an application like this would be to identify each one of its resources: remember that each resource has its own URI.
A URI for the products and a URI for each product
A URI for the Purchase Orders and a URI for each one.
etc
Consider the methods that you need to implement. For example, to let end users access the list of products - GET, to access each product (GET), to insert a purchase order (POST) or to update an order (PUT). Check this article: REST Protocol considerations for more considerations to take into account when designing your API.
Besides, take into account the parameter types, it is recommended to use basic data types (scalar types such as numeric, string, date, GUID) when using the GET and DELETE verbs, because they will use the URL queryString to transfer it; the Output does not have this restriction.
In GeneXus, developing and/or consuming a Rest service is an easy task.
As you'll see in the following articles, a Rest service is generated by setting just an object property, and the specification document of this service is generated automatically.
With respect to consuming a Rest service (it can be generated by GeneXus or not), GeneXus provides the OpenAPI import tool."
118,Artificial Intelligence,"https://wiki.genexus.com//commwiki/wiki?40167,Table+of+contents%3AGeneXus+Cognitive+API","GeneXus provides capabilities to easily integrate cognitive services into your system. You do not have to be an expert on such a discipline or know how it works. You just set a few parameters, give your data as input and take the result.
Among the main task offered by GeneXus are image classification, facial recognition, audio transcription, text analysis, etc. Also, you can combine all these simple tasks for building sophisticated systems with a great look.
Some examples of what you could achieve.
Image processing

Audio processing 



""The first question that comes up is: What is GeneXus? GeneXus is a tool that automatically generates software programs such as applications for the Web, and Smart Devices, always at the forefront of technological evolution.""

       



Speaking...





 


Speaking...
0:00
Check GeneXusAI Module Overview article for further information and start developing."
119,Payment services,"https://wiki.genexus.com//commwiki/wiki?50600,APIs+to+integrate+with+payment+methods","This article lists the different APIs available in GeneXus to integrate your applications with different payment services providers.
GeneXus SDK for Mercado Pago
GeneXus SDK for PayPal
GeneXus SDK for Stripe
WeChat Pay API
Alipay API
Note:  These APIs are typically developed with GeneXus, using integration and extensibility capabilities to.
See Also
Rest web services in GeneXus

OpenAPI import tool


External Object: Native Object

"
120,Knowledge Manager,"https://wiki.genexus.com//commwiki/wiki?5679,Category%3AKnowledge+Manager+Menu","






The Knowledge Manager is a GeneXus component that is in charge of interchanging objects among Knowledge Bases.

The process of extracting a set of objects is known as Export, and the process of importing them in another Knowledge Base is known as Import. When you export, an XPZ is created, which is later read when you import.
In addition to the process of importing and exporting objects, you can use the Manage Module References option to install a module provided by other developers. For more information, check: Manage Module References article.
See Also
Knowledge Manager Export
Knowledge Manager Import
Knowledge Manager Team Development
View Last Import Log
"
121,Export,"https://wiki.genexus.com//commwiki/wiki?3942,Knowledge+Manager+Export","Knowledge Manager Export provides a mechanism for sharing Knowledge Base information among other GeneXus developers.

You can export one or more objects from a Knowledge Base. Some options are available to help you with this task. By default, all objects are exported (the Export All checkbox is checked). You may export, however, only a few of them (Add button) and also add those objects referenced by the ones you select (References button).
If you select the Options link, you are able to modify some options in the Properties window, by the following:
Include untranslated messages. Include the untranslated messages in the distribution file, by default these messages are not included.
Include GeneXus messages. Include the GeneXus messages in the language object, by default these messages are not included.
References Type. This option is used when: Including objects through the Select Object dialog box (the selected objects' references are calculated), dragging and dropping an object into the dialog box (the dragged objects' references are calculated); and when pressing the references button (references are calculated for all the objects in the tree).
	
None - Does not include any reference.
Minimal (default) - Includes references of the object needed to be imported into an empty KB. Includes references to attributes, domains and SDTs referenced by objects; in the case of transactions, table is included.
All - Brings all referenced objects.
Hard - It includes only hard references from the selected objects. The idea is to leave out weak references (a typical case, to prevent the master page from being included in the list when it is associated to a selected object by default, inheriting the property from the KB). Some examples of hard references are when an object is called from another object or when two objects are related through a NO default property.


Dependency Type. export related objects  which are referenced by or references to:
	
ReferencesTo - exports objects the selected one references. For example; if object A calls B; the ReferencedTo option adds the B Object when exporting A.
ReferencedBy - exports object referenced by the selected objects. For example; if object A calls B; the ReferencedTo option adds the A Object when exporting B.
Tip: use the Object References dialog to navigate object dependencies.
Export with selected objects: Push Add button, then select objects from Select Objects dialog window.

If you need to add objects referenced by those you selected push the Reference button.









"
122,Import,"https://wiki.genexus.com//commwiki/wiki?3179,Knowledge+Manager+Import","The import process in GeneXus is intended for knowledge-sharing among developers. You import what someone else (or yourself) exported. Changes made to your application by other team members, new developments that need to be included in your application, and existing ""application blocks"" (see GXopen) are only a few examples of Knowledge Manager Import uses.
The Knowledge Manager Import dialog allows you to:
Select and load an export file to import.
See the objects in the export file.
Select the objects you want to import.
Automatically convert export files from older GeneXus versions and save the converted export file. This conversion is made when a previous version export file is loaded and a message appears telling you that this conversion has been made.
Filter results by import result (i.e., objects with errors, warnings or OK messages).
Specify import options.

The Import process updates the Output window with relevant process status, warnings and errors.
Note that, while importing, Full Text Search indexing is paused (if not already). Once the import process ends, indexing resumes.
Note
When the Automatic Backup option is set to Yes, a Frozen Version is created in the Knowledge Base with the backup remaining visible in the KnowledgeBase Versions tool window.
Videos
Exporting and Importing GeneXus Objects
"
123,Team Development,"https://wiki.genexus.com//commwiki/wiki?31337,Table+of+contents%3AGeneXus+Server","GeneXus Server is a product designed to facilitate the teamwork of developers. It offers simple, powerful and efficient solutions to the problems faced daily by teams of developers, such as:
Synchronization: between different developers. GeneXus Server guarantees that developers will be working with the latest version of the project and always aware of its current status.
History: each object in a Knowledge Base has a revision history of its own (Activity Log). This is shown when changes are made to an object, allowing the selection of a previous revision as the current one.
Revert changes: tired of not knowing how to revert changes when something went wrong? GeneXus Server solves this with just one click on the Revert option.
GeneXus Server automates knowledge integration while strongly improving the capacity of teamwork with GeneXus.
A Knowledge Base administered by GeneXus Server enables authorized developers to send and receive modifications from the Server Knowledge Base, while centralizing business knowledge and integrating the development team.
This is possible regardless of whether team members are scattered around the world or all together at one location.

Each Developer, works individually on his/her own local Knowledge Base, independently from the rest, but synchronized with them through the GeneXus Server Knowledge Base. When the developer's work is done or must be backed up, it is sent to the Server, and this provides developers with an automatic detailed History of all changes made in every object, with the name of those responsible for each change, and the possibility of reverting the current revision of an object back to an older revision.
Download
GeneXus Server may be downloaded from here
Give it a try!
Try GeneXus Server:
Sandbox GeneXus Server: http://sandbox.genexusserver.com/
Access other plans on the cloud (http://gxserver.com/en/plans) or get a local installation (http://gxserver.com/en/main/local-gxserver)
Videos
GeneXus Server. Introduction"
124,Explore remote KB,"https://wiki.genexus.com//commwiki/wiki?42133,Explore+and+Integrate+Knowledge+from+Remote+Knowledge+Bases","This feature enables you to explore remote Knowledge Bases from within the GeneXus IDE. It is a practical way to view, copy, and integrate content from remote KBs into the KB that is opened in GeneXus.
Note:  To be able to explore and integrate from a remote KB, the latter must be hosted in a GeneXus Server.
How to Explore Remote Knowledge Bases
To explore a remote Knowledge Base, go to the Knowledge Manager menu, and select Explore Remote Knowledge Base

A new dialog will open that lists all the registered GXservers and the hosted KBs for each GXserver. Select the Knowledge base you want to explore and click on the 'Select' button.



This will open a new dialog that shows the KB and version that is being explored, as well as a Remote KB Explorer which lists the contents of the KB; in the same way, the GeneXus KB Explorer lists all objects in the opened KB.
You can change the KB being explored by clicking on the button next to the KB Name.
You can change the version being explored by changing the value of the combo box next to the Version label.

From this dialog, you can access the entire content of Explore Knowledge Base, remotely. This is similar to the way you can explore a local KB in GeneXus, except that in this case the KB being explored is hosted in GXserver. To open an object, double-click on it, in the same way you would do in the KB Explorer.


After double-clicking an object, GeneXus will contact GXserver to retrieve the contents of the remote object. While this operation is in progress, a loader icon is displayed in the window. Once the object has been correctly retrieved, it is automatically opened in GeneXus editor:


From this editor, you can explore the remote object in the same way you would explore any object in your local Knowledge Base. You can see its properties, code, variables, and even copy any code or controls you want into your own Knowledge Base, directly, without having to create the KB from GXserver at any time. You can also reposition the object location in the Remote KB Explorer, from the object menu by right-clicking on the object tab and selecting 'Locate in Remote KB Explorer.'

Now suppose you would like to integrate some of the contents of a remote Knowledge Base into your opened KB. In this case, you would most likely want to bring a set of objects, maybe all objects contained in a specific module. To be able to perform this task in a really practical way, the Remote Explorer has a set of selected objects that can be imported at any time.
Click an object from the Remote KB explorer and select one of the two options for marking the object as selected:


In this case, we added all of the objects present in the Alipay module to the selected object list. Selected objects can be listed grouped by type or individually.


When all the selected objects you want are in the list, you can integrate these objects by clicking on the downright button 'Import in Local KB'



This will contact GXserver and retrieve all the objects and their contents, and launch an import operation from the import dialog.



Availability
This feature is available since GeneXus 17 upgrade 3.

"
125,Manage Module References,"https://wiki.genexus.com//commwiki/wiki?40172,Manage+Module+References","Manage Module References is another option (together with Knowledge Manager Import) for knowledge sharing among developers. You can install a module provided by other developers that have packaged their funcionalities for distribution.
The Manage Module References dialog allows you to:
Look for external modules on servers (including your local machine).
Install, Update, or Restore a module in the Knowledge Base.
Get information about the module, including its version, author, description, license, platforms available, etc.

The Install/Update process displays the relevant process status, warnings, and errors in the Output window. Make sure it is open to see the information.
Module Installation
GeneXus uses the Maven repository for managing and downloading modules from its Global Matrix. However, when defining your own repository, you can choose between Maven and NuGet for module management and downloading. To do so, you must configure the repository as a Module Server and specify whether it is a Nexus - NuGet or Nexus - Maven repository. This way, GeneXus will use the selected repository to manage the modules and their dependencies.
Maven
Maven is widely used and allows for dependency management, which simplifies the installation and update of modules in GeneXus.
To use Maven as a module server, you must have Maven installed. You can download it from the official Maven site.
NuGet
NuGet is presented as a recommended alternative, as it automatically manages dependencies.
When using NuGet, if a module A depends on another module B, it is not necessary to have module B previously installed. GeneXus, in conjunction with NuGet, automatically installs the required dependencies before installing the main module. This approach significantly simplifies the process of installing and updating modules, especially when working with a considerable number of modules and their respective dependencies.
Make sure you have NuGet installed by looking for the ""nuget.exe"" file in %userprofile%\.gxmodules\.tools. If you cannot find it, you can download it from the official NuGet site.
Troubleshooting
Symptom: When Installing, ""pmm0037: Maven installation not found.""
error: Error downloading module '<module>' from 'Global Matrix' (internal error: 'pmm0037: Maven installation not found. Please, add Maven installation 'bin' path to environment variable 'PATH'.').
Reason: GeneXus requires Maven 3.6.1 or higher for installing modules from a Nexus Modules Server.
Solution: You must update Maven.
Symptom: Error accessing Global Matrix through Maven.
error: Error downloading module '<module>' from 'Global Matrix' (internal error: 'Object reference not set to an instance of an object.').
In gxlogging.log you can see the following error:
PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
Reason: The error occurs due to a change in the certificate of the Matrix site you are trying to access through Maven in GeneXus. The error message indicates that a valid certification path to the requested target could not be found, preventing the artifacts from being transferred correctly.
Solution: To solve the problem, it is necessary to update the JDK or manually update the certificate in the Java version of the development machine so that the new certificate used by the Matrix server is recognized. This will allow you to establish a secure connection and resolve the error. More information is available at SAC #52914.
See Also
When and how is the GeneXus module updated in a KB?
"
126,View Last Import Log,"https://wiki.genexus.com//commwiki/wiki?9574,View+Last+Import+Log","A report that informs you on the outcome of the Import process after the implicit verifications have been performed.

The Log's buttons footer displays the total number of new objects, warnings objects and objects with errors that were detected during consolidation. The left pane displays the list of consolidated objects, including their names and descriptions.
See Also
Knowledge Manager Import









"
127,Environments,"https://wiki.genexus.com//commwiki/wiki?7115,Category%3AEnvironments","One of the benefits of using GeneXus is that it makes possible the generation of applications running on many different platforms (from a Web interface, a watch, cell phone, tablet or TV, to cloud server farms). It generates code in different programming languages and stores the application data in different databases.
An Environment allows you to set and store all the information related to a certain implementation of your application, for example: the generators you want to use to generate the Back end of your application, the generators to be used to generate the Front end, the database information, etc.
When creating a Knowledge Base, a default Environment is created.
The ""New Knowledge Base"" dialog —in addition to asking you for the Knowledge Base name and path— it requests you to select the programming language to be used to generate the code corresponding to the application Back end, as well as the programs to create/modify the database structure (called Reorganization programs). The rest of the Environment information must be configured through its properties.

So, after the Knowledge Base creation, you can verify the default Environment is created by selecting the Preferences tab located next to the KB Explorer tab:

The default Environment name (i.e. "".NET Environment"", ""Java Environment"", etc.) can be changed by editing the Name property. In the same way, if you want to change the programming language, you can modify the Language property. And so you can set the different Environment properties.
An Environment is made up of the following nodes:
Back end: It refers to everything related to the application server, the accesses to the database, and the services.  
Front end: It refers to everything related to the UI (what is shown and used to interact) and connects with the Back end. So, the resources to generate (and set) these are .NET, Java, Angular, Android, Apple. 
Deployment: It refers to the Deployment Unit objects defined in the KB Version.
1. Back end
The Back end node defines:
The programming language(s) that will be used to generate the code corresponding to the application Back end as well as the programs to create/modify the database structure. There is a Default language (in the shown example is .NET given that it was selected at the Knowledge Base creation time) and it is possible to define more generators for specific scenarios. Learn more about GeneXus Generators.
The Default Data Store to set the information to access to the database associated with your generated application. It is also possible to create other Data Stores to read external databases.
The Services node, whose properties allow you to configure the handling of services, storage settings, notifications, etc.
2. Front end
It shows the generators available to generate the Front end of the application so that you can configure their properties. By default, the generators shown are: .NET, Android, and Apple. You can add the Angular generator by setting the Front end Generate Angular property to Yes.
3. Deployment
This node allows you to define different Deployment Unit objects.
Working with several Environments
Each Environment stores the details corresponding to a specific application implementation.
To define a new Environment, being positioned on the KB Version node or on the Default Environment node, right-click and select ""New Environment"". The New Environment dialog will be opened.
Only one Environment can be active at a time, which means that will be the one used to generate the application, reorganize the database, and run when pressing F5.
The one active by default is the Default Environment.
To get an Environment ""active"", right-click on its name (over the root node of the environment tree) and click on ""Set As Current Environment"". When it becomes active, the name of the Environment is highlighted with bold case and the icon next to the name shows an orange arrow (i.e. ""PLAY"" symbol) to indicate that that Environment will be the one used.
An inactive Environment is indicated with its name case not bold that shows that the Environment will not be used in generating, nor in connecting to a database.
Considerations
When changing Environment properties usually a Rebuild All is needed, for more details check Applying property changes.
"
128,Knowledge Base Versions,"https://wiki.genexus.com//commwiki/wiki?5680,Category%3AKnowledge+Base+Versions","An application life cycle has several milestones called Versions in GeneXus. A Version holds the status of an application at any given time. It may be a read-only version holding a ""photo"" of the application at any important time during development. Common names for read-only versions are: Sent to QA, Version 1.0 final, Version 2 as installed in customer X. Versions may also represent separate development threads, sample version names in this case may be, for example: Fixes to QA version, Upgrades to Version 1.0 final,  Hot fixes to Version 2 as installed in customer X.
Having versions of an application in a Knowledge Base targets the following scenarios:
Separating development threads.
Being able to continue application development while fixing another version (s) without disrupting each other.
Analyzing changes between application versions
Easily comparing versions, moving changes from one to another, etc.
Restoring to a previously known state
Versions can be used to make a backup of your applications before making ""what if"" changes.
Basic application customization
Even though versions are not the ideal method for customization, they can be used for this purpose in some situations.
A typical development process
Every new Knowledge Base has a default development version. Opening the Knowledge Base Versions tool window shows this default version, which has the name of the Knowledge Base. Development starts on this version, and it continues until you decide that the desired level of functionality and stability has been reached, and it's time to release your work to customers.

At release time, it is a good idea to make a copy of your application as it is released. This is called ""Freezing"" a version and the result is a Frozen version. Right clicking on the default version node shows the Freeze option. Selecting the Freeze option prompts you for the name and description that will be assigned to the new Frozen version. Default values are good enough at this time, so let GeneXus create your new Frozen version, ""Version 1"".

Having created a frozen version, you can switch between them (right click on any of them and set it to Active) and perform the following actions:
Continue application development on the next release
See exactly what was released as of ""Version 1""
Compare both versions
Fixing the ""Version 1"" version
The ""Version 1"" version is a Frozen version. It cannot be changed. If you need to fix it, you must create a new version. Right click on ""Version 1"" and select the New Version option. Leave the default names and description and create the new version. The new version ""Upgrades for Version 1"" is an exact copy of what was released on ""Version 1"".

Now the diagram shows three versions, one of them is Frozen. Set the ""Upgrades for Version 1"" to active (Set as Active on context menu). From then on, any change you make in objects, or any objects created or removed will go to ""Upgrades for Version 1"". Other versions will not be affected.

When you've made all the fixes to ""Upgrades for Version 1"", it's time to release. Once again, select the Freeze option on ""Upgrades for Version 1"" in the context menu. Leave the default names for the new Frozen version.

At this time you are able to:
Continue application development on the next release
See exactly what was released as of ""Version 1""
Regenerate the application as of ""Version 1""
Continue adding fixes to ""Version 1"" (changing ""Upgrades to Version 1"")
See exactly what was released as of ""Version 1.1"" (fixes for ""Version 1"")
Regenerate the application as of ""Version 1.1""
Compare any versions
Various fix sets for ""Version 1"" version
While not desirable, sometimes it is necessary to create a separate development thread just to make specific fixes. The most common example is having two customers experiencing different problems. When the first problem arises, you create the ""Upgrades for Version 1"" version and fix it as described above. Later, the second problem arises in a different customer. This customer accepts the fix to his or her problem, and nothing but that fix (i.e. you cannot fix the problem in ""Upgrades for Version 1"" as it already has another fix). The solution to this is to create a new version from ""Version 1"" (select New Version from the ""Version 1"" context menu) and fix the new problem in this version.

Note the horizontal line starting on ""Version 1"" and linked to ""Upgrades for Version 1"" and ""Upgrades 2 for Version 1""). It states that both versions share a common starting point (""Version 1"").
Continue application development
After an application is released, work usually begins on a new version. The most common tasks are adding new features, making major changes, and introducing fixes to existing versions. The new version is not started from scratch, so: where are these changes made? In what version? They are made in the default development version, the one at the top (root) of the Knowledge Base Versions Diagram.
The development cycle continues until your application is ready to be released again. To create a new Frozen version, select the Freeze context menu option of the root node and leave the default names.

By now you should've already realized how the cycle works: develop -> freeze -> develop -> freeze ... This cycle applies to any Development Version.
Reading the Knowledge Base Versions Diagram
The Knowledge Base Versions Diagram shows the version hierarchy. Each vertical line is a timeline representing a development thread. Earlier versions in each thread are closer to the top of each vertical line. A horizontal line connects versions sharing a common parent Frozen version.
Frozen versions are displayed as light-brown filled rectangles connected to a vertical line. At the top of this line there is always a Development Version.
Development versions are displayed as rounded rectangles connected to one Frozen version. Many Development versions can be connected to a single Frozen one meaning they all share a common source base.

Version naming convention
Versions can have any name you choose, as long as they are not duplicated. Usually, Frozen version have numbers (1, 2, 3, 1.1, 3.2, etc.) and Development ones are named (code name like Yi, Rocha, Solis, etc.).
Frequently Asked Questions
How do I know what version I'm working on?
The current version is displayed in the Preferences and in the Folder View tool windows as shown in the following image.

Comparison with previous GeneXus versions
This section is for GeneXus users that are used to working on versions prior to GeneXus X. The concept of Knowledge Base is a bit different in this version.
Each GeneXus X Version should be considered a Knowledge Base in prior GeneXus versions. A GeneXus X Knowledge Base is, therefore, a set of Knowledge Bases of prior GeneXus versions. A couple of examples may help you understand the concept:
If you want to
GeneXus X
Prior GeneXus versions


Create a copy of your application at a given milestone. For example, at release time
Freeze a version
Copy Knowledge Base directory to a new one


Continue development for the next version
Set the default development version as active
Open the development Knowledge Base


Fix a released application
Create a (development) Version from the corresponding Frozen one and set it as active
Copy the previous backup directory to a new one


Make a new, separate fix, for released application
Create another (development) Version from the corresponding Frozen one and set it as active
Copy the previous backup directory to a new one

See Also
Version Properties
Version Management and Work Methodology with GeneXus Server



"
129,DevOps in GeneXus,"https://wiki.genexus.com//commwiki/wiki?38363,Table+of+contents%3ADevOps+in+GeneXus","The industry requires that software delivery could be agile and continuous.
To achieve this, DevOps aims to integrate the different work teams (Developer team, Test team, Operation team, Design team, Security team, etc.) and work in an integrated way to be able to continuously deliver a quality product.
Among the practices that must be carried out in order to implement DevOps in organizations, there are three important issues that should be considered: the way in which teams, processes, and tools related to those processes work to allow the continuous delivery of value to the users.
DevOps helps to foster collaboration between the different teams that participate in the creation of systems, promote effective communication using tools and methods, so that all team members are synchronized and all are part of the development process.
Statistics show that DevOps teams work 30 times faster, fail 60 times less, and recover 160 times quicker from failures.
A culture of trust and a feeling of fellowship were sharing ideas, issues, processes, tools, and goals are the fundamental bases of the DevOps practices and it’s important to keep them aligned in order to have fewer conflicts in the team.
It is also necessary to adopt an agile development methodology, in order to achieve these objectives."
130,GeneXus Server,"https://wiki.genexus.com//commwiki/wiki?31337,Table+of+contents%3AGeneXus+Server","GeneXus Server is a product designed to facilitate the teamwork of developers. It offers simple, powerful and efficient solutions to the problems faced daily by teams of developers, such as:
Synchronization: between different developers. GeneXus Server guarantees that developers will be working with the latest version of the project and always aware of its current status.
History: each object in a Knowledge Base has a revision history of its own (Activity Log). This is shown when changes are made to an object, allowing the selection of a previous revision as the current one.
Revert changes: tired of not knowing how to revert changes when something went wrong? GeneXus Server solves this with just one click on the Revert option.
GeneXus Server automates knowledge integration while strongly improving the capacity of teamwork with GeneXus.
A Knowledge Base administered by GeneXus Server enables authorized developers to send and receive modifications from the Server Knowledge Base, while centralizing business knowledge and integrating the development team.
This is possible regardless of whether team members are scattered around the world or all together at one location.

Each Developer, works individually on his/her own local Knowledge Base, independently from the rest, but synchronized with them through the GeneXus Server Knowledge Base. When the developer's work is done or must be backed up, it is sent to the Server, and this provides developers with an automatic detailed History of all changes made in every object, with the name of those responsible for each change, and the possibility of reverting the current revision of an object back to an older revision.
Download
GeneXus Server may be downloaded from here
Give it a try!
Try GeneXus Server:
Sandbox GeneXus Server: http://sandbox.genexusserver.com/
Access other plans on the cloud (http://gxserver.com/en/plans) or get a local installation (http://gxserver.com/en/main/local-gxserver)
Videos
GeneXus Server. Introduction"
131,Send Knowledge Base to GeneXus Server,"https://wiki.genexus.com//commwiki/wiki?10215,Send+Knowledge+Base+to+GeneXus+Server","The Send Knowledge Base to Server operation is used when you have a local Knowledge Base and want to publish it in a GeneXus Server instance so it can be served as a teamworking GeneXus Server Knowledge Base.
Step by step
After creating the local Knowledge Base, the following steps must be executed:
1) Select the Send Knowledge Base to Server option located under the File option.
2) A dialog will show up where you must enter the GeneXus Server url and the Knowledge Base alias. Note: the Knowledge Base alias must be unique in the GeneXus Server instance.

Notes:
You can choose to export all versions by clicking the CheckbBox All versions in Knowledge Base. Otherwise, only the active version of the Knowledge Base will be sent.
The Work with Lock or Merge model option it's also available. By default the Merge model is selected, to select the Work with Lock model the Work With Lock Model option must be chosen. Please refer to HowTo: Change between Merge and Lock Models to know how to change the Team Collaboration Mode Property after the Knowledge Base has been sent to the GeneXus Server.
3) After clicking Send GeneXus will gather all the necessary information from the local Knowledge Base to send it to the GeneXus Server instance. This process may take a few minutes, depending on the size of the Knowledge Base.

Check the Team Development output section for further information.
A success message must be displayed; if not, see GeneXus Server Common Issues.

4) The Knowledge Base is now served by the selected GeneXus Server instance, so other users can perform a Create Knowledge Base from GeneXus Server operation (from the IDE or using Team Development MSBuild Tasks) and selecting the recently uploaded Knowledge Base.
The local Knowledge Base is now linked to the one on the GeneXus Server. This means that from now on, you will be able to work in a team working environment by updating and committing changes.
Note: once a Knowledge Base has been sent to a GeneXus Server instance, the option Send Knowledge Base to Server will be unavailable from the File menu.
See also
Create Knowledge Base from GeneXus Server










"
132,Checkout,"https://wiki.genexus.com//commwiki/wiki?22416,Create+Knowledge+Base+from+GeneXus+Server","The Knowledge Base from GeneXus Server option is the first operation you have to complete in order to subscribe to a Knowledge Base hosted in a GeneXus Server instance.
It's located under the File > New menu in the GeneXus IDE.

Step by step
1) Select the Knowledge Base from GeneXus Server option from the File>New menu. The following prompt will be shown:


2) If you know the Knowledge Base URL then you just have to write it in Server KB URL and continue with the following step. Otherwise, click Select Server KB to select the Server's Knowledge Base from a list of available GeneXus Servers
After clicking the Select Server KB option, a new window will be prompted to select the GeneXus Server Instance from the Servers list. Open and Sandbox instances are listed by default:


The wanted Server must be chosen. If the GeneXus Server instance isn’t listed, to add it to the list the Add New Server option must be selected:
Write all the required information:
URL: The GeneXus Server URL to connect.
Friendly Name: Name that will be used in the Server's list for the instance.
Authentication Type: Corresponding Authentication Type.
Username: GeneXus Account or Local username.
Password: GeneXus Account or Local password.
Click Check Connection to test the Server's connection (using the selected username and password) and click OK to add the GeneXus Server instance to the Servers list.

Note: The username and password can be remembered using the Save Password CheckBox. If the Save Password checkbox isn't enabled, the next time you want to connect to the GeneXus Server an authentication dialog will be displayed:
3) Once you are connected to a GeneXus Server Instance, a list of Knowledge Bases served by this GeneXus Server is displayed in Knowledge Bases:


Select one Knowledge Base from the list, by double-clicking on it or by clicking and then pressing Ok.
Note: Filter Knowledge Bases using the search box located above the list, for easy and fast Knowledge Base searching. This is especially useful to create a Knowledge Base from a GeneXus Server Instance populated with several Knowledge Bases.
4) After a Knowledge Base has been selected, the Version(s) must be chosen. You can choose to import only the Trunk version, to import All versions, or to import a custom set of Selected versions.


Select all the Development Versions and/or Frozen Versions from that Knowledge Base.

Note: To choose a custom set of Versions select Selected Versions on the radio button and then click the ""..."" button. A dialog will be displayed:
Check all the versions to import (if more than one Version is selected a Minimum Spanning Tree will be automatically selected). Notice that filters can be applied by using the search box located above the list.
5) Once the Versions are selected set Name and Path of the Knowledge Base and click the Create button.

Note: Use Advanced Setting to configure Knowledge Base storage properties.
Next, a progress bar will be displayed showing the three steps involved in the creation of a KB:
Once all steps have been completed, the Knowledge Base created will be an exact copy of the Knowledge Base hosted in the GeneXus Server. After this process, the connection to GeneXus Server is dropped and you are ready to work off-line.

Note that the Team Development node located under the Preferences has been updated.
See also
Send Knowledge Base to GeneXus Server


"
133,Knowledge Manager Team Development,"https://wiki.genexus.com//commwiki/wiki?20864,Knowledge+Manager+Team+Development","Knowledge Manager Team Development provides the mechanism for interacting with a GeneXus Server instance. It is accessed through the Knowledge Manager Menu by selecting the Team Development option.

See also
Commit to GeneXus Server
Update From GeneXus Server
Team Development History dialog




"
134,Commit to GeneXus Server,"https://wiki.genexus.com//commwiki/wiki?10626,Commit+to+GeneXus+Server","The Commit to Server operation is executed to update a Knowledge Base hosted in a GeneXus Server instance.
Once a set of changes is completed, the Developer must publish them. Publishing changes is called Commit and requires the GeneXus Server to be active and accessible to the Developer.
Step by step
To perform a Commit operation the Developer must follow the steps below:
1) Select the Knowledge Manager >Team Development menu option to open the Knowledge Manager Team Development dialog and choose the Commit tab.

2) Press the Refresh button  to load the set of objects that have been changed locally since the last Commit operation.
3) The Developer can select/deselect the objects to Commit.
4) The developer must type a Comment detailing what these changes mean (explaining the changes to another Developer). As a rule of thumb write a simple, one-line sentence that briefly explains the Commit and then write a few more sentences providing greater detail.

5) Click the Commit button to finish. All the changes will be packaged and sent to the GeneXus Server and the Knowledge Base will be updated. Use the Team Development output section (Output window) to verify that the Commit operation was successful.
Note:
Knowledge Base Environment and Version properties can also be included in the Commit operation.
Filters can be applied using the Filter option:

Add to ignored objects option
Using the Add to ignored objects option from the contextual menu the Developer will be able to ignore objects so that they are not sent. These will be included in the list in the Ignored Objects tab and left there until they are (explicitly) recovered in a future Commit operation.


Note: Filters can be applied using the Filter option:
Pending Commits and Ignored Objects columns
Column
Description




Selection Checkbox
Used to select whether the object is included in the Commit operation.


Action Icon
Displays an icon showing the action performed to the object.


Object Icon
Displays the icon of the object.


Name
Displays the Name property of the object.


Type
Displays the object Type property.


Description
displays the Description property of the object.


Modified On
Last date when the object was modified—causing to be included in the pending commit list. This property column does not behave as the ""Modified On"" of the History dialog.


Module
Module to which the object belongs to.


Action
the action performed to the object, the possible values are: Inserted, Modified or Deleted.


Last Synchronized
Displays the date of the last synchronization, in other words, the time where the object was Updated or created by the Create Knowledge Base from GeneXus Server operation.


User
User who performed the last modification.
Remind me to move changes to...
Please see Bring Changes Reminder to understand fully how to use this feature.
The Commit Number can be used to Bring Changes/Bring All Changes from another Development Version
See also
ChangeSets in GeneXus Server
Partial Commit to GeneXus Server
Update From GeneXus Server
Revert Object Operation
Warn When Adding Or Removing Objects From Selection Property



"
135,Update From GeneXus Server,"https://wiki.genexus.com//commwiki/wiki?10627,Update+From+GeneXus+Server","The Update From Server operation allows incorporating to the local Knowledge Base those changes made in the Server Knowledge Base since the last Update From Server operation.
Step by step
To perform an Update operation, the Developer must follow the steps below:
1) Select the Knowledge Manager->Team Development menu option to open the Knowledge Manager Team Development dialog and choose the Update tab.

Note: Remember that by double-clicking upon an object the comparer window will be open showing the differences between the object's local content and the server one.
2) Select the Update option to incorporate all the selected modifications into your local Knowledge Base (those objects which weren't selected in the Pending for Update tab will not be updated). Check the Team Development output window to make sure the operation was completed successfully.
Note: Also, the Developer will be able to pick the group of properties to import from GeneXus Server by checking the KB Properties CheckBox.
Update To a specific revision
If the Developer wants to update to a specific revision, at the top-right of the tab, he could change the revision to update from. The Developer could select any revision and update from it. Suppose your local Knowledge Base is at revision 10, but you want it to reflect the state which it had in revision 2 - then simply update to revision 2.
Note: By default, the update is compared to the last revision at GeneXus Server. The revisions mentioned above can be find in the Activity of the Knowledge Base in GeneXus Server.
Update Options
If any object fails to Update, GeneXus provides two options:

1) Fail on errors: The entire operation is reverted, and no object gets modified.
In these cases, GeneXus may automatically deselect the objects with errors, so that the Developer can easily retry a new update which doesn't include the failed objects. By default, GeneXus will ask for confirmation before automatically deselecting the objects with errors.
Using the Automatically deselect objects after failed Update, located Tool->Options->Team Development, the Developer will be able to configure this behavior.

The possible values are:
Always: Automatically deselect all the objects (and referenced objects) that fail on an update operation (without asking for user confirmation)
Never: Never deselect objects.
Ask: Ask the user each time.
2) Continue on errors: Those objects which were successfully updated are kept while the failed objects' behavior is defined by the Developer.
For more information, please refer to Update behavior.
See Also
Commit to GeneXus Server




"
136,Revert Object Operation,"https://wiki.genexus.com//commwiki/wiki?31967,Revert+Object+Operation","The Revert option allows the Developer to get rid of those changes which aren't yet committed and to reset the object to the way it was before the edition.
The operation discards the changes and reverts to the committed revision the Developer started with (the revision which corresponds to the last Commit or Update operation performed from the client that includes the object; Update with Merge are not considered).





"
137,Team Development History dialog,"https://wiki.genexus.com//commwiki/wiki?31949,Team+Development+History+dialog","The History tab from the Team Development dialog allows inspecting all the performed Commits, showing those objects which were part of it, and comparing differences between the local object and the one on the Server side.

Where:
The Version ComboBox allows determinating the version of the Knowledge Base to see the Commit history.

The list of committed objects is shown when a specific Commit is selected, detailing the Commit number, Comment, User, and Date. 
When right clicking on any commit a set of operations will be displayed. These operations vary depending on the selected Commit.
Note: Filters can be applied:

Using To and From ComboBox, which allows setting a range of dates to filter the list of Commits.
Using Search the Developer will be able to filter the list by some string.
Operations available on the Commits history
The operations shown in the context menu depend on whether the Developer is looking at the commits done to the same version his KB version is connected to, or to a different version:
For commits to the same version, the Developer will be able to perform a Revert a Commit on any Commit.

For commits to other versions, the Developer will be able to perform a Bring Changes from a selected Commit.

Note: in both scenarios, the Developer will be able to perform a Get export file from Commit operation, which allows generating an xpz file with the objects of the selected Commit.
Operations available on the objects list
There are three differents options:

Show Differences: will open a comparator window detailing the state of the object before and after the Commit

Show Server History: will display a new screen where showing the detail of all the commits in which the object was involved.


Blame: allows knowing which user performed a determined change.




"
138,Manage versions with GXserver,"https://wiki.genexus.com//commwiki/wiki?19747,Manage+versions+with+GeneXus+Server","When working with a Knowledge Base that has more than one GeneXus Server version, it's necessary to administrate the different versions.
So, when performing a Create Knowledge Base from GeneXus Server operation or a Send Knowledge Base to GeneXus Server operation, you are allowed to choose from a subtree of versions to receive/send from/to GeneXus Server.
1) When creating a Knowledge Base from GeneXus Server the Create Knowledge Base from GeneXus Server will be displayed:

After selecting the wanted Knowledge Base, you will be able of choosing the versions to be imported by selecting the Selected versions option which displays the following popup:

You will have to choose the corresponding versions and then create the Knowledge Base.

2) When sending a Knowledge Base to GeneXus Server, you will also have the possibility of choosing which versions of the local Knowledge Base send to GeneXus Server.
After selecting the Send Knowledge Base to GeneXus Server option (located under the File tab), the following dialog will be shown:

Then, you will have to choose the corresponding versions to send to GeneXus Server.
Considerations
When selecting a subtree of versions, the root element must be a Development Version. Also, all the selected versions must be part of that subtree.




"
139,Application Security,"https://wiki.genexus.com//commwiki/wiki?24746,Table+of+contents%3AGeneXus+Access+Manager+%28GAM%29","
The majority of modern applications need some scheme of authentication/authorization. To cover these aspects, GeneXus provides a mechanism (called GeneXus Access Manager) to offer a single, centralized scheme with everything related to application authentication and authorization.
The GeneXus Access Manager (GAM) provides a GAM API to manage all the security issues concerning an application. Therefore, the security module of any application (web applications and mobile applications) is provided by GAM. Also, security controls are automatically performed by GAM.
The GAM API contains the implementation of all the functionalities related to security issues: user administration (registration, authentication, password administration, security policies), roles, etc.
To activate GAM in your Knowledge Base, you have just to set the Enable Integrated Security property to True.
GAM is based on the Role Based Access Control (RBAC) model.
It has its own database, logically independent from the database application, even though they can both be physically the same (with different table schemes).
End users (administrator users) can manage users and security policies through the GAM Web Backoffice.
Requirements
GAM executes the initialization of the database using the same platform as the model. If it's a Java model, the GAM processes which run within the IDE to initialize the GAM database structure and the metadata (applications registration, permissions creation, etc) are executed in Java.
	In the case of those DBMSs that GeneXus doesn't distribute the JDBC drivers, you have to copy them manually to <genexus>\gxjava\drivers (to the classpath configured in GeneXus).
If the GAM datastore is different from MySQL or SQL Server, a setup is launched from the GeneXus IDE to install the GAM platform corresponding to the selected DBMS. See GAM platforms for more information. The setup is distributed so as to run it in standalone mode, under <GeneXus>\Library\GAM\Setup folder.
In web applications, GAM uses the web session to store user session data. As in any other web application, when load balancing environments are used, the servers need to persist the session (or use server affinity) so that the web session is available to the workers that respond to the request.
First Steps
GAM Overview Video
GAM - Getting Started
GAM Authentication
GAM Authentication
GAM Authorization
GAM - Authorization"
